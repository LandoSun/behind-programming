<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="summary.html">
<link rel="next" href="section-4.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Behind Programming</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 编程背后</a></li>
<li class="chapter" data-level="2" data-path="summary.html"><a href="summary.html"><i class="fa fa-check"></i><b>2</b> Summary</a></li>
<li class="chapter" data-level="3" data-path="c.html"><a href="c.html"><i class="fa fa-check"></i><b>3</b> C++编码规范</a><ul>
<li class="chapter" data-level="3.1" data-path="c.html"><a href="c.html#section-3.1"><i class="fa fa-check"></i><b>3.1</b> 目的</a></li>
<li class="chapter" data-level="3.2" data-path="c.html"><a href="c.html#section-3.2"><i class="fa fa-check"></i><b>3.2</b> 体例结构</a></li>
<li class="chapter" data-level="3.3" data-path="c.html"><a href="c.html#philosophy"><i class="fa fa-check"></i><b>3.3</b> 理念（Philosophy）</a><ul>
<li class="chapter" data-level="3.3.1" data-path="c.html"><a href="c.html#p.0-"><i class="fa fa-check"></i><b>3.3.1</b> P.0 以人为本</a></li>
<li class="chapter" data-level="3.3.2" data-path="c.html"><a href="c.html#p.1-"><i class="fa fa-check"></i><b>3.3.2</b> P.1 演进的自洽</a></li>
<li class="chapter" data-level="3.3.3" data-path="c.html"><a href="c.html#p.2-"><i class="fa fa-check"></i><b>3.3.3</b> P.2 品质的生活</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="c.html"><a href="c.html#design-principles"><i class="fa fa-check"></i><b>3.4</b> 设计原则（Design Principles）</a><ul>
<li class="chapter" data-level="3.4.1" data-path="c.html"><a href="c.html#d.1-"><i class="fa fa-check"></i><b>3.4.1</b> D.1 保持一致性</a></li>
<li class="chapter" data-level="3.4.2" data-path="c.html"><a href="c.html#d.2-"><i class="fa fa-check"></i><b>3.4.2</b> D.2 保持向下兼容性</a></li>
<li class="chapter" data-level="3.4.3" data-path="c.html"><a href="c.html#d.3-"><i class="fa fa-check"></i><b>3.4.3</b> D.3 有损服务，柔性可用</a></li>
<li class="chapter" data-level="3.4.4" data-path="c.html"><a href="c.html#d.4-apisla"><i class="fa fa-check"></i><b>3.4.4</b> D.4 API设计意识与SLA服务意识</a></li>
<li class="chapter" data-level="3.4.5" data-path="c.html"><a href="c.html#d.5-"><i class="fa fa-check"></i><b>3.4.5</b> D.5 测试驱动开发</a></li>
<li class="chapter" data-level="3.4.6" data-path="c.html"><a href="c.html#d.6-"><i class="fa fa-check"></i><b>3.4.6</b> D.6 代码中的文档</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="c.html"><a href="c.html#format"><i class="fa fa-check"></i><b>3.5</b> 代码格式化（Format）</a><ul>
<li class="chapter" data-level="3.5.1" data-path="c.html"><a href="c.html#f.0-"><i class="fa fa-check"></i><b>3.5.1</b> F.0 克制重新格式化代码的冲动</a></li>
<li class="chapter" data-level="3.5.2" data-path="c.html"><a href="c.html#f.1-"><i class="fa fa-check"></i><b>3.5.2</b> F.1 注释</a></li>
<li class="chapter" data-level="3.5.3" data-path="c.html"><a href="c.html#f.2-include"><i class="fa fa-check"></i><b>3.5.3</b> F.2 <code>#include</code></a></li>
<li class="chapter" data-level="3.5.4" data-path="c.html"><a href="c.html#f.3-"><i class="fa fa-check"></i><b>3.5.4</b> F.3 行宽</a></li>
<li class="chapter" data-level="3.5.5" data-path="c.html"><a href="c.html#f.4-"><i class="fa fa-check"></i><b>3.5.5</b> F.4 缩进</a></li>
<li class="chapter" data-level="3.5.6" data-path="c.html"><a href="c.html#f.5-"><i class="fa fa-check"></i><b>3.5.6</b> F.5 括号</a></li>
<li class="chapter" data-level="3.5.7" data-path="c.html"><a href="c.html#f.6-"><i class="fa fa-check"></i><b>3.5.7</b> F.6 换行与空行</a></li>
<li class="chapter" data-level="3.5.8" data-path="c.html"><a href="c.html#f.7-"><i class="fa fa-check"></i><b>3.5.8</b> F.7 空格</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="c.html"><a href="c.html#source-file"><i class="fa fa-check"></i><b>3.6</b> 源文件代码组织(Source File)</a><ul>
<li class="chapter" data-level="3.6.1" data-path="c.html"><a href="c.html#sf.1-header-file"><i class="fa fa-check"></i><b>3.6.1</b> SF.1 头文件（Header File）</a></li>
<li class="chapter" data-level="3.6.2" data-path="c.html"><a href="c.html#sf.2-definition-file"><i class="fa fa-check"></i><b>3.6.2</b> SF.2 定义文件（Definition File）</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="c.html"><a href="c.html#naming"><i class="fa fa-check"></i><b>3.7</b> 命名(Naming)</a><ul>
<li class="chapter" data-level="3.7.1" data-path="c.html"><a href="c.html#n.0-"><i class="fa fa-check"></i><b>3.7.1</b> N.0 命名一般规范</a></li>
<li class="chapter" data-level="3.7.2" data-path="c.html"><a href="c.html#n.1-"><i class="fa fa-check"></i><b>3.7.2</b> N.1 文件名</a></li>
<li class="chapter" data-level="3.7.3" data-path="c.html"><a href="c.html#n.2-"><i class="fa fa-check"></i><b>3.7.3</b> N.2 命名空间</a></li>
<li class="chapter" data-level="3.7.4" data-path="c.html"><a href="c.html#n.3-"><i class="fa fa-check"></i><b>3.7.4</b> N.3 类型命名</a></li>
<li class="chapter" data-level="3.7.5" data-path="c.html"><a href="c.html#n.4-"><i class="fa fa-check"></i><b>3.7.5</b> N.4 常量命名</a></li>
<li class="chapter" data-level="3.7.6" data-path="c.html"><a href="c.html#n.5-"><i class="fa fa-check"></i><b>3.7.6</b> N.5 变量命名</a></li>
<li class="chapter" data-level="3.7.7" data-path="c.html"><a href="c.html#n.6-"><i class="fa fa-check"></i><b>3.7.7</b> N.6 函数命名</a></li>
</ul></li>
<li class="chapter" data-level="3.8" data-path="c.html"><a href="c.html#basics"><i class="fa fa-check"></i><b>3.8</b> 基础编码（Basics）</a><ul>
<li class="chapter" data-level="3.8.1" data-path="c.html"><a href="c.html#b.0-"><i class="fa fa-check"></i><b>3.8.1</b> B.0 防御性编程</a></li>
<li class="chapter" data-level="3.8.2" data-path="c.html"><a href="c.html#b.1-"><i class="fa fa-check"></i><b>3.8.2</b> B.1 合理使用配置</a></li>
<li class="chapter" data-level="3.8.3" data-path="c.html"><a href="c.html#b.2-"><i class="fa fa-check"></i><b>3.8.3</b> B.2 严禁使用幻数</a></li>
<li class="chapter" data-level="3.8.4" data-path="c.html"><a href="c.html#b.3-raii"><i class="fa fa-check"></i><b>3.8.4</b> B.3 用RAII管理资源的申请与释放</a></li>
<li class="chapter" data-level="3.8.5" data-path="c.html"><a href="c.html#b.4-"><i class="fa fa-check"></i><b>3.8.5</b> B.4 防止不必要的范围扩大</a></li>
<li class="chapter" data-level="3.8.6" data-path="c.html"><a href="c.html#b.5-"><i class="fa fa-check"></i><b>3.8.6</b> B.5 变量应有清晰而唯一的用途</a></li>
<li class="chapter" data-level="3.8.7" data-path="c.html"><a href="c.html#b.6-"><i class="fa fa-check"></i><b>3.8.7</b> B.6 规避已知编码问题</a></li>
<li class="chapter" data-level="3.8.8" data-path="c.html"><a href="c.html#b.7-"><i class="fa fa-check"></i><b>3.8.8</b> B.7 重视警告</a></li>
</ul></li>
<li class="chapter" data-level="3.9" data-path="c.html"><a href="c.html#function-body"><i class="fa fa-check"></i><b>3.9</b> 函数体代码组织（Function Body）</a><ul>
<li class="chapter" data-level="3.9.1" data-path="c.html"><a href="c.html#fb.0-"><i class="fa fa-check"></i><b>3.9.1</b> FB.0 函数应中心明确，语义清晰，详略得当，条理分明</a></li>
<li class="chapter" data-level="3.9.2" data-path="c.html"><a href="c.html#fb.1-"><i class="fa fa-check"></i><b>3.9.2</b> FB.1 函数参数</a></li>
<li class="chapter" data-level="3.9.3" data-path="c.html"><a href="c.html#fb.2-"><i class="fa fa-check"></i><b>3.9.3</b> FB.2 函数复杂度</a></li>
<li class="chapter" data-level="3.9.4" data-path="c.html"><a href="c.html#fb.3-"><i class="fa fa-check"></i><b>3.9.4</b> FB.3 主流程函数</a></li>
<li class="chapter" data-level="3.9.5" data-path="c.html"><a href="c.html#fb.4-ifelse-ifelse"><i class="fa fa-check"></i><b>3.9.5</b> FB.4 写周全的<code>if/else if/else</code></a></li>
<li class="chapter" data-level="3.9.6" data-path="c.html"><a href="c.html#fb.5-c"><i class="fa fa-check"></i><b>3.9.6</b> FB.5 C++异常风格的异常处理</a></li>
<li class="chapter" data-level="3.9.7" data-path="c.html"><a href="c.html#fb.6-"><i class="fa fa-check"></i><b>3.9.7</b> FB.6 返回值风格的异常处理</a></li>
<li class="chapter" data-level="3.9.8" data-path="c.html"><a href="c.html#fb.7-"><i class="fa fa-check"></i><b>3.9.8</b> FB.7 日志打印</a></li>
</ul></li>
<li class="chapter" data-level="3.10" data-path="c.html"><a href="c.html#class-body"><i class="fa fa-check"></i><b>3.10</b> 类体代码组织（Class Body）</a><ul>
<li class="chapter" data-level="3.10.1" data-path="c.html"><a href="c.html#c.1-"><i class="fa fa-check"></i><b>3.10.1</b> C.1 构造函数应合理初始化</a></li>
<li class="chapter" data-level="3.10.2" data-path="c.html"><a href="c.html#c.1-"><i class="fa fa-check"></i><b>3.10.2</b> C.1 类的成员（草稿中）</a></li>
<li class="chapter" data-level="3.10.3" data-path="c.html"><a href="c.html#todo"><i class="fa fa-check"></i><b>3.10.3</b> TODO</a></li>
</ul></li>
<li class="chapter" data-level="3.11" data-path="c.html"><a href="c.html#section-3.11"><i class="fa fa-check"></i><b>3.11</b> 类组织</a></li>
<li class="chapter" data-level="3.12" data-path="c.html"><a href="c.html#language-feature"><i class="fa fa-check"></i><b>3.12</b> 语言特性使用（Language Feature）</a><ul>
<li class="chapter" data-level="3.12.1" data-path="c.html"><a href="c.html#l.1-c"><i class="fa fa-check"></i><b>3.12.1</b> L.1 C语言特性使用</a></li>
<li class="chapter" data-level="3.12.2" data-path="c.html"><a href="c.html#l.2-c9803"><i class="fa fa-check"></i><b>3.12.2</b> L.2 C++98/03语言特性使用</a></li>
<li class="chapter" data-level="3.12.3" data-path="c.html"><a href="c.html#l.3-c1114"><i class="fa fa-check"></i><b>3.12.3</b> L.3 C++11/14语言特性使用</a></li>
</ul></li>
<li class="chapter" data-level="3.13" data-path="c.html"><a href="c.html#section-3.13"><i class="fa fa-check"></i><b>3.13</b> 标准库与第三方库使用</a></li>
<li class="chapter" data-level="3.14" data-path="c.html"><a href="c.html#section-3.14"><i class="fa fa-check"></i><b>3.14</b> 团队定制规则</a></li>
<li class="chapter" data-level="3.15" data-path="c.html"><a href="c.html#section-3.15"><i class="fa fa-check"></i><b>3.15</b> 参考文献</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="section-4.html"><a href="section-4.html"><i class="fa fa-check"></i><b>4</b> 前端小队开发指引</a><ul>
<li class="chapter" data-level="4.1" data-path="section-4.html"><a href="section-4.html#section-4.1"><i class="fa fa-check"></i><b>4.1</b> 前端生态了解</a></li>
<li class="chapter" data-level="4.2" data-path="section-4.html"><a href="section-4.html#section-4.2"><i class="fa fa-check"></i><b>4.2</b> 前端工作流选型</a></li>
<li class="chapter" data-level="4.3" data-path="section-4.html"><a href="section-4.html#section-4.3"><i class="fa fa-check"></i><b>4.3</b> 前端技术选型</a></li>
<li class="chapter" data-level="4.4" data-path="section-4.html"><a href="section-4.html#section-4.4"><i class="fa fa-check"></i><b>4.4</b> 前端开发规范参考</a></li>
<li class="chapter" data-level="4.5" data-path="section-4.html"><a href="section-4.html#section-4.5"><i class="fa fa-check"></i><b>4.5</b> 编辑器选择</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="section-5.html"><a href="section-5.html"><i class="fa fa-check"></i><b>5</b> 应急预案模版</a><ul>
<li class="chapter" data-level="5.1" data-path="section-5.html"><a href="section-5.html#section-5.1"><i class="fa fa-check"></i><b>5.1</b> 背景</a></li>
<li class="chapter" data-level="5.2" data-path="section-5.html"><a href="section-5.html#checklist"><i class="fa fa-check"></i><b>5.2</b> 冲刺工作CHECKLIST</a><ul>
<li class="chapter" data-level="5.2.1" data-path="section-5.html"><a href="section-5.html#section-5.2.1"><i class="fa fa-check"></i><b>5.2.1</b> 预备变更</a></li>
<li class="chapter" data-level="5.2.2" data-path="section-5.html"><a href="section-5.html#section-5.2.2"><i class="fa fa-check"></i><b>5.2.2</b> 核验确保</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="section-5.html"><a href="section-5.html#section-5.3"><i class="fa fa-check"></i><b>5.3</b> 预判瓶颈</a></li>
<li class="chapter" data-level="5.4" data-path="section-5.html"><a href="section-5.html#section-5.4"><i class="fa fa-check"></i><b>5.4</b> 预案概述</a><ul>
<li class="chapter" data-level="5.4.1" data-path="section-5.html"><a href="section-5.html#section-5.4.1"><i class="fa fa-check"></i><b>5.4.1</b> 预案动作原则</a></li>
<li class="chapter" data-level="5.4.2" data-path="section-5.html"><a href="section-5.html#section-5.4.2"><i class="fa fa-check"></i><b>5.4.2</b> 默认触发条件</a></li>
<li class="chapter" data-level="5.4.3" data-path="section-5.html"><a href="section-5.html#section-5.4.3"><i class="fa fa-check"></i><b>5.4.3</b> 自动预案</a></li>
<li class="chapter" data-level="5.4.4" data-path="section-5.html"><a href="section-5.html#section-5.4.4"><i class="fa fa-check"></i><b>5.4.4</b> 人工预案</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="section-5.html"><a href="section-5.html#section-5.5"><i class="fa fa-check"></i><b>5.5</b> 值守指引</a></li>
<li class="chapter" data-level="5.6" data-path="section-5.html"><a href="section-5.html#section-5.6"><i class="fa fa-check"></i><b>5.6</b> 瓶颈预案</a></li>
<li class="chapter" data-level="5.7" data-path="section-5.html"><a href="section-5.html#section-5.7"><i class="fa fa-check"></i><b>5.7</b> 风险预案</a></li>
<li class="chapter" data-level="5.8" data-path="section-5.html"><a href="section-5.html#section-5.8"><i class="fa fa-check"></i><b>5.8</b> 归因预案</a></li>
<li class="chapter" data-level="5.9" data-path="section-5.html"><a href="section-5.html#section-5.9"><i class="fa fa-check"></i><b>5.9</b> 预案演习计划</a></li>
<li class="chapter" data-level="5.10" data-path="section-5.html"><a href="section-5.html#checklist"><i class="fa fa-check"></i><b>5.10</b> 扫尾工作CHECKLIST</a><ul>
<li class="chapter" data-level="5.10.1" data-path="section-5.html"><a href="section-5.html#section-5.10.1"><i class="fa fa-check"></i><b>5.10.1</b> 复原变更</a></li>
<li class="chapter" data-level="5.10.2" data-path="section-5.html"><a href="section-5.html#section-5.10.2"><i class="fa fa-check"></i><b>5.10.2</b> 观察核验</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="c" class="section level1">
<h1><span class="header-section-number">第 3 章</span> C++编码规范</h1>
<div id="section-3.1" class="section level2">
<h2><span class="header-section-number">3.1</span> 目的</h2>
<p>本规范尝试：</p>
<ul>
<li>博采众家C++编程规范之长，将其中对一个团队的编程水平和质量影响最大的规范，形成一个适度的最小集，并以文字重新表述出来</li>
<li>将一些未被采选但依然有益的规则（主要是仅针对不常用的语言特性或库的），以综述类规则的形式索引起来备用</li>
</ul>
<p>意在确定一个具备如下优势的C++编程规范：</p>
<ul>
<li>学习成本低（太多的规则给人过大的心智负担，以至于直接泡汤）</li>
<li>易于达成共识（不会浪费太多时间在争论上，最多弃用其中几条，或采取规则的变种）</li>
<li>便于施行（很容易在代码检视制度中贯彻，或采用静态代码检查工具扫描、强制）</li>
</ul>
<p>但本编程规范是带有强烈个人理念的、有态度的编程规范，无意适应、取悦众口。</p>
<p>对于仅关心具体编程规范的读者，可以直接跳过“体例结构”、“理念”两节，从“代码格式化”开始阅读。</p>
</div>
<div id="section-3.2" class="section level2">
<h2><span class="header-section-number">3.2</span> 体例结构</h2>
<p>编程规范的编辑体例，应该像GoF在著名的《设计模式》中一样，构筑自洽完备的表述结构，就像代码的组织要遵循良好的结构一样。</p>
<p>《Google C++ Style Guide》的“Definition/Pros/Cons/Decision”的体例，更像一份讨论权衡而不是规范，留下了很多模糊的空间，没有保持逻辑的自洽，更像一个折衷产物和半成品，且部分条款具备误导性（参考<a href="https://www.linkedin.com/pulse/20140503193653-3046051-why-google-style-guide-for-c-is-a-deal-breaker">《Why Google Style Guide for C++ is a deal-breaker》</a>）。《LLVM Coding Standards》的体例更像散文。《C++ Coding Standards》的“Item title/Summary/Examples/Exceptions/References”不够完备。《高质量C++/C 编程指南》采用的规则条文式体例，每条规则都干净专注，有其可取之处，但本规范希望将相关的一系列规则融合成一体。</p>
<p>本编程规范的编辑体例与组织结构，基本与C++之父Bjarne Stroustrup最新尚在Github上协作撰写的、面向C++14的《C++ Core Guidelines》(下文简称<code>CCG</code>)一致，从其他编程规范中，也吸取了部分元素。</p>
<p>编程规范由许多条编程规则组成，相关联的规则，组成小节。</p>
<p>每个规则具备如下要素：</p>
<ul>
<li><strong>编号</strong>（Reference Number）：为了方便在代码review中引用。采用字母缩写与数字序号相结合的方式。同一小节内的字母缩写一致，与该节内容的单词所含的字母相关。优先采用单个大写字母或多个单词的手字母大写缩写，其次考虑一个单词内首字母大写、再取1-2个字母小写的缩写。</li>
<li><strong>规则标题</strong>（Rule）：言简意赅的规则描述，采用格言文风。其表述只需让初读者能猜出大致与什么相关，以及让已阅者朗朗上口，易于回想其含义即可。</li>
<li><strong>阐述</strong>（Elaboration）：对规则的含义进行一定的展开描述。一般是先阐述规则的内涵，再通过列表的形式来展开规则的外延。</li>
<li><strong>例外</strong>（Exceptions）：规则往往有例外，如果不将有限的、可以接受的例外纳入规则，规则就会被无穷的、不可接受的例外所吞噬。</li>
<li><strong>因由</strong>(Reasons/Rationales)：解释这样做的好处、不这样做的坏处，以及该规则为什么可以入选这个“最小集”。自由桀骜的程序员不会盲从权威的规定，但愿意遵循合理的游戏规则。</li>
<li><strong>样例</strong>(Examples)：包括正面和反面的例子，可以适度包括对其后果的演示。抽象的描述是难以让人理解领会的。样例能够帮助人在提炼共性中加深理解。</li>
<li><strong>备选方案</strong>（Alternatives）：适用于禁令式的规则，给人一条出路。被禁止的做法原来想解决的问题，总得有个被鼓励/允许的做法来解决。演示怎样做才能规避被禁止的做法的弊端，而不引入新的弊端。</li>
<li><strong>贯彻手段</strong>(Enforcement)：如何机械式地在代码自查/检视中发现这些问题？如何使用自动化工具（如静态代码检查工具扫描、强制）？</li>
<li><strong>参考</strong>（See alsos）：参考相关的规则，或者先贤及其他编程规范，对该规则的阐述与讨论，包括一些反对该规则的理由。</li>
</ul>
<p>每个规则可复制如下这段模板后开始撰写，可适当移除不必要的要素（如例外、备选方案及之后的要素）：</p>
<pre><code>### X.1 规则标题

...阐述直接开始...

__例外__

__因由__

__样例__

__备选方案__

__贯彻手段__

__参考__</code></pre>
<p>用语规范:</p>
<blockquote>
<p>TODO 待规范用语后在此说明，如：</p>
</blockquote>
<ul>
<li>术语：</li>
<li>函数/方法</li>
<li>定义文件/源文件</li>
<li>团队/组织</li>
<li>列表中句号的使用</li>
</ul>
</div>
<div id="philosophy" class="section level2">
<h2><span class="header-section-number">3.3</span> 理念（Philosophy）</h2>
<div id="p.0-" class="section level3">
<h3><span class="header-section-number">3.3.1</span> P.0 以人为本</h3>
<p>让计算机的特性为人服务。</p>
<p>计算机的特性，包括硬件（如CPU二级缓存）、语言（如lambda）、库（如boost）的特性，包括正面的便利之处与反面的约束之处。</p>
<p>人包括：</p>
<ul>
<li>需求方：尽一切可能，不让实现或者计算机特性，影响到目标的达成，寻求合理的方案利用正面的特性，克制反面的约束，除非需求自身不合理，或影响软件的长期维护。</li>
<li>开发人员：代码应具备较强的可读性，便于后来者理解（进行白盒分析）和维护（进行调整修改）。</li>
<li>测试人员：代码应通过合理的模块化组织，提升可测试性（黑盒测试）。即使不采取TDD（测试驱动开发），也应持续添加自动化测试用例，至少在发现bug时。</li>
<li>运维人员（后台系统）/技术支持人员（软件）：代码的运行，应留有便于调整（如修改参数）和观察（如定位问题）的口子，就像汽车应该提供仪表的观察界面和驾驶的操作界面。</li>
</ul>
<p><strong>因由</strong></p>
<p>我们是人类。</p>
<p><strong>样例</strong></p>
<p>反面：</p>
<ul>
<li>不熟悉语言特性与潜在的坑，能解决问题的特性不用，能绕过的坑掉进去</li>
<li>使用生僻的语言特性，代码让人难以一目了然</li>
<li>变量命名晦涩随意</li>
<li>因为语法没有规定格式，就不重视代码的格式，只要程序能跑就好</li>
<li>意大利面条般、几百万光年外都耦合的代码</li>
<li>写死的参数</li>
<li>对规范（比如本规范）厌烦，从而不能充分利用编码规范提升自己的生产力、效率和水平。</li>
</ul>
</div>
<div id="p.1-" class="section level3">
<h3><span class="header-section-number">3.3.2</span> P.1 演进的自洽</h3>
<p>自洽，即自己与自己不矛盾，有清晰一致的内在逻辑性（如因果性、规则优先序列等），没有潜规则、陷阱和过多的例外。</p>
<p>演进，即演化、进步，是一种动态的视野与格局。演进的自洽不是僵化的千篇一律的硬性规定。它因其清晰一致的内在逻辑性，具备不断演化、完善补充的生命力，同时，也具备对新规则和新理念的包容性，只要具备协调一致的可能。</p>
<p>虽然两者对立统一，但演进以自洽为前提，有其内在优先序列。</p>
<p>这个理念在团队管理场景的另外一个表述，是“遵循并构建规约”，展开如下：</p>
<ul>
<li>团队的规范与原则，入乡随俗，予以遵循并主动尝试理解和了解其中的合理性</li>
<li>非必要不制造规范和原则的例外，而不是小事都可以含糊随意，造成破窗效应，千里之堤毁于蚁穴</li>
<li>充分理解现状和存在的先例后，为空白区域构建新的规范，或对现有规范加以归纳或优化</li>
<li>对团队讨论形成的最终结论，予以执行而不会阳奉阴违</li>
</ul>
<p><strong>因由</strong></p>
<ul>
<li>理性的人做事情，总有一定道理可循。讲一次道理容易，讲一辈子道理不容易，关键在于道理之间的自洽。</li>
<li>自洽的规则，易于建立直观理解，符合直觉，能降低理解和遵循规则的心智负担。</li>
<li>支离破碎、东一榔头西一棒子的规则，不成体系，只是半成品，容易在自身冲突抵消和例外侵蚀下分崩离析，难以建立长久权威。</li>
<li>公说公有理婆说婆有理，谁应被采纳？更能纳入现有自洽的规则体系内的，应被采纳。破而后立，不应是常态。</li>
</ul>
<p><strong>样例</strong></p>
<ul>
<li>D.1 保持一致性</li>
<li>D.2 保持向下兼容性</li>
</ul>
</div>
<div id="p.2-" class="section level3">
<h3><span class="header-section-number">3.3.3</span> P.2 品质的生活</h3>
<p>生活，即接地气，不脱离实践、架空、学院派，不陷入盲目的理想主义，不会教条主义地适用某个牛逼的原则。</p>
<p>品质，即品味与质量，能够拒绝坏味道，能够追求更优的质量，更高的标准，更佳的实践。</p>
<p>应持续追求，以合理的代价，在合适的时机，将合用的业界良好实践，运用到实际的编程活动中，贴合实际又不乏预见性地解决编程活动中的痛点。</p>
<p>虽然两者对立统一，但品质以生活为前提，有其内在优先序列。</p>
<p><strong>因由</strong></p>
<ul>
<li>许多编程从业者的编码时间不长，但却从各种书籍里，或者网上的博客里，接受过许多金科玉律般的编程理念，在实际编码中，容易纠结于这些规则（很多规则之间，应用起来，容易相互冲突，但没有明确的优先级序列来指引），或者追求牛逼或优雅，脱离了实际的需求，所以需要优先强调接地气。</li>
<li>编程活动往往承受巨大进度压力（上线前或出问题后），容易在实践中渐渐远离那些初识编程时学到的原则，放弃趋近，甚至逐渐认为那些都中看不中用，直至深深陷入救火的恶性循环，代码质量和团队水平一路堕落。</li>
</ul>
<p><strong>样例</strong></p>
<p>不接地气的坏例子：</p>
<ul>
<li>早熟的性能优化</li>
<li>追求适应一切需求弹性、每次极小改动的通用化万能设计</li>
</ul>
<p>不追求品质的坏例子：</p>
<ul>
<li>单词拼写错误</li>
<li>代码粘贴拷贝</li>
<li>手工重复测试</li>
<li>忽视代码规范</li>
</ul>
<p>品质的良好例子：</p>
<p>遵循UNIX编程哲学，详见<a href="http://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html">《The Art of Unix Programming》之《Basics of the Unix Philosophy》</a></p>
<blockquote>
<ul>
<li>Rule of Modularity: Write simple parts connected by clean interfaces.</li>
<li>Rule of Clarity: Clarity is better than cleverness.</li>
<li>Rule of Composition: Design programs to be connected to other programs.</li>
<li>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</li>
<li>Rule of Simplicity: Design for simplicity; add complexity only where you must.</li>
<li>Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</li>
<li>Rule of Transparency: Design for visibility to make inspection and debugging easier.</li>
<li>Rule of Robustness: Robustness is the child of transparency and simplicity.</li>
<li>Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.</li>
<li>Rule of Least Surprise: In interface design, always do the least surprising thing.</li>
<li>Rule of Silence: When a program has nothing surprising to say, it should say nothing.</li>
<li>Rule of Repair: When you must fail, fail noisily and as soon as possible.</li>
<li>Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</li>
<li>Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</li>
<li>Rule of Optimization: Prototype before polishing. Get it working before you optimize it.</li>
<li>Rule of Diversity: Distrust all claims for “one true way”.</li>
<li>Rule of Extensibility: Design for the future, because it will be here sooner than you think.</li>
</ul>
</blockquote>
<p>遵循面向对象的<a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">S.O.L.I.D原则</a>：</p>
<blockquote>
<ul>
<li>S – Single-responsiblity principle</li>
<li>O – Open-closed principle</li>
<li>L – Liskov substitution principle</li>
<li>I – Interface segregation principle</li>
<li>D – Dependency Inversion Principle</li>
</ul>
</blockquote>
</div>
</div>
<div id="design-principles" class="section level2">
<h2><span class="header-section-number">3.4</span> 设计原则（Design Principles）</h2>
<div id="d.1-" class="section level3">
<h3><span class="header-section-number">3.4.1</span> D.1 保持一致性</h3>
<ul>
<li>技术选型、代码风格等与所属模块保持一致性，团队内模块间保持一致性。</li>
<li>尽可能使用和改善团队内公共的基础设施，而不是自写一套个性化的实现，除非有一系列与基础设施在定位、侧重点、方案取舍等方面存在难以融入却又有必要的差异、定制。</li>
<li>不要违背这两点给他人制造惊喜与陷阱。</li>
</ul>
</div>
<div id="d.2-" class="section level3">
<h3><span class="header-section-number">3.4.2</span> D.2 保持向下兼容性</h3>
<ul>
<li>保持向下兼容性，无故不删除函数或修改同名函数语义。</li>
<li>要进行破坏兼容性修改时，应经过团队讨论，并只在Major版本时进行，不在Minor和Patch版本进行，参考<a href="http://semver.org/">《Semantic Versioning》</a>。</li>
<li>应维护模块的changelog，包括新增的功能与修复的bug，参考<a href="http://keepachangelog.com/">《Keep a CHANGELOG》</a>。底线是，在版本合入主干时，以写changelog的认真态度，写commit message，参考<a href="http://chris.beams.io/posts/git-commit/">《How to Write a Git Commit Message》</a>和<a href="https://github.com/bluejava/git-commit-guide">《The bluejava Git Commit Message Format Guide》</a>。更好的建议是用单独的文件来维护changelog。</li>
</ul>
</div>
<div id="d.3-" class="section level3">
<h3><span class="header-section-number">3.4.3</span> D.3 有损服务，柔性可用</h3>
<ul>
<li>通过接受并运营牺牲，来提升系统整体支撑能力，确保关键功能的可用性。</li>
<li>在设计阶段就考虑，当系统不能提供完美体验时，设定多级主动体验降级，来为用户提供更好的体验过渡。</li>
</ul>
</div>
<div id="d.4-apisla" class="section level3">
<h3><span class="header-section-number">3.4.4</span> D.4 API设计意识与SLA服务意识</h3>
<ul>
<li>把每一个模块、子模块、类、函数，都当做API来精心雕琢设计，为使用者提供便利。</li>
<li>把每一个子功能，都当做一项服务、一个产品，给出相应的服务标准（SLA）的承诺，并以之为目标导向。</li>
</ul>
<p><strong>API</strong></p>
<ul>
<li>Application：应用、场景、需求、用例</li>
<li>Programmable：组合、套餐、解决方案、时序图</li>
<li>Interface：</li>
<li>提供风格一致的界面</li>
<li>入参/出参</li>
<li>初始化/前置条件/后置条件</li>
<li>行为</li>
<li>避免副作用，或明确以文档/注释说明</li>
<li>异常结果的表达方式（返回值与异常）</li>
<li>授权/来源/分层/作用域</li>
</ul>
<p><strong>SLA</strong></p>
<ul>
<li>Service：</li>
<li>特性（定性）
<ul>
<li>功能</li>
<li>安全</li>
<li>可用性（例如：120分钟；99.97%）</li>
<li>性能</li>
<li>吞吐量</li>
<li>时耗</li>
<li>总量</li>
<li>超频弹性</li>
<li>需求响应速度</li>
<li>设计灵活性</li>
<li>研发效率</li>
<li>资源调度能力</li>
<li>成本</li>
</ul></li>
<li>对象（QoS）</li>
<li>Level：</li>
<li>量化</li>
<li>分级</li>
<li>交付时间</li>
<li>Agreement：</li>
<li>正常：
<ul>
<li>用户端：Expectation</li>
<li>服务端：Goal</li>
</ul></li>
<li>一次灾难或部分二次灾难
<ul>
<li>用户端：Acceptance</li>
<li>服务端：Bottom Line</li>
</ul></li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/32713.pdf">How to Design a Good API and Why it Matters</a></li>
<li><a href="http://people.mpi-inf.mpg.de/~jblanche/api-design.pdf">The Little Manual of API Design</a></li>
<li><a href="https://www.cs.cmu.edu/~charlie/courses/15-214/2014-fall/slides/17-api-design.pdf">Principles of API Design by Charlie Garrod &amp; Jonathan Aldrich</a></li>
<li><a href="https://wiki.qt.io/API_Design_Principles">API Design Principles in Qt</a></li>
</ul>
</div>
<div id="d.5-" class="section level3">
<h3><span class="header-section-number">3.4.5</span> D.5 测试驱动开发</h3>
<ul>
<li>自测通过自动化单元测试进行，而非手工架设依赖的环境并手工触发测试。</li>
<li>通过构造测试用例，来思考代码的异常路径的逻辑。</li>
<li>考虑代码的可测试性，内部代码也组织成小小的API。</li>
<li>新增的工具函数和关键业务逻辑必须编写配套的自动化测试用例（如Java使用JUnit，C++使用Google Test），前者相当于单元测试，后者相当于粗略的集成测试。</li>
<li>应持续提升自动化测试覆盖率。</li>
<li>对依赖的外部系统，必须写能够模拟正常和异常返回的桩，利于联调测试开展。</li>
<li>可以通过<a href="https://en.wikipedia.org/wiki/Test_fixture#Software">夹具(Fixture)</a>来提升编写自动化测试用例的效率。</li>
</ul>
</div>
<div id="d.6-" class="section level3">
<h3><span class="header-section-number">3.4.6</span> D.6 代码中的文档</h3>
<ul>
<li>写文档（详见F.1）</li>
<li>读文档</li>
<li>对业已存在的文档尽可能进行阅读理解与自我重新组织。</li>
<li>避免出现“不写文档我不知道、写了文档我还是不知道”的局面。</li>
<li>不依赖文档</li>
<li>在没有文档或文档不准确的时候，通过阅读自动化测试用例以及分析理解代码意图来把握代码。</li>
<li>不要想当然地以文档、函数的命名或者自己的预期来判断代码的实际功能、内部逻辑与副作用。</li>
<li>避免出现“别人写的代码太晦涩了，我怎么想得到这里会有这么一个弯弯绕绕，出了错也不是我的责任”这类思想上的借口。</li>
<li>建立文档索引：</li>
<li>文档越积越多，势必变得难以找到需要的文档；文档也逐步失去时效性，充满了过时的信息；恶化到极致，对同样的系统，有不同时期写成的多个版本的文档，每个互不了解，各自提供部分信息和部分误导。</li>
<li>因此，应为文档建立索引（而不仅是提供搜索），从而让同一领域的文档，有固定的集散地，相互呼应、关联，共同提供有效和最新的信息。</li>
</ul>
</div>
</div>
<div id="format" class="section level2">
<h2><span class="header-section-number">3.5</span> 代码格式化（Format）</h2>
<div id="f.0-" class="section level3">
<h3><span class="header-section-number">3.5.1</span> F.0 克制重新格式化代码的冲动</h3>
<p>对已有的代码基，尽量模仿其格式和风格（哪怕只是一个文件、一个类、一个函数的局部风格），而不要轻易因为个人喜好，重新格式化。</p>
<p><strong>因由</strong></p>
<ul>
<li>在没有取得对于格式的统一认识之前，每个人都因个人喜好重新格式化代码，会形成代码格式的冲突和混乱。</li>
<li>随意地重新格式化代码，会使得代码review时无法清晰看出有意义的修改点，从而导致隐藏bug。</li>
</ul>
<p><strong>例外</strong></p>
<p>有两种情况下进行代码的重新格式化，是可以的：</p>
<ul>
<li>本来就要对某个局部进行大的逻辑重构，而该局部目前的代码风格不符合团队成文的格式规范。</li>
<li>团队内取得共识，有计划地基于成文的格式规范，集中进行代码的重新格式化。</li>
</ul>
<p>但注意：</p>
<ul>
<li>格式化的修改需要单独commit，并在commit log中加以说明。</li>
<li>严禁在一次commit中混杂有意义的修改和纯粹的格式化。</li>
<li>不宜在一系列的commit中穿插有意义的修改和纯粹的格式化，而应分别集中做有意义的修改，和纯粹的格式化。</li>
</ul>
<p><strong>贯彻手段</strong></p>
<p>团队应在代码基形成初期就对代码格式达成统一共识，集中将代码格式统一，并提供统一工具在每次commit前自动格式化，确保后继无需再为格式操心。</p>
<p>一个优秀的代码格式化工具是<a href="http://astyle.sourceforge.net/astyle.html">Astyle</a>，本规范的格式可以用如下选项运行Astyle：</p>
<pre><code>astyle --recursive --indent=spaces=2 *.cpp *.h</code></pre>
<p>根据在F.5中对花括号换行风格的选择，还可以增加不同的<code>--style</code>选项，详见F.5。</p>
<p>还可以增加如下选项使之符合本规范风格：</p>
<ul>
<li><code>--indent-col1-comments</code> / <code>-Y</code>：将注释和下一行代码对齐。</li>
<li><code>--break-blocks</code> / <code>-f</code>： ‘if’, ‘for’, ’while’等代码块前后增加1个空行。</li>
<li><code>--pad-oper</code> / <code>-p</code>：二元操作符两侧增加1个空格。</li>
<li><code>--unpad-paren</code> / <code>-U</code>：确保括号两侧无空格。</li>
<li><code>--align-pointer=type --align-reference=type</code> / <code>-k1 -W1</code>：确保<code>*</code>和<code>&amp;</code>靠近类型而不是变量名。</li>
<li><code>--add-brackets</code> / <code>-j</code>：确保’if’, ‘for’, ’while’等代码块如果只有1条语句，依然加花括号。</li>
<li><code>--remove-comment-prefix</code> / <code>-xp</code>：去掉多行注释每行的<code>*</code>前缀，并将注释尾端的<code>*/</code>前的空格去掉。</li>
<li><code>--max-code-length=80 --break-after-logical</code> / <code>-xC80 -xL</code>：在逻辑操作符、逗号、括号、分号或空格处断开，使得每行长度小于80。</li>
</ul>
<p>其他值得注意的地方：</p>
<ul>
<li>实际格式化之前，请使用<code>--dry-run</code>测试效果。</li>
<li>对于外部代码或其他不希望格式化的代码，请使用<code>--exclude=</code>选项排除</li>
<li>可以考虑将部分规则自动化，每次commit均执行，而另外部分规则，工具自动提示修改的地方，但人工确认才生效。</li>
</ul>
<p>综合起来，可将如下<code>.astylerc</code>放在项目的根目录并运行<code>astyle --recursive --options=.astylerc *.cpp *.h</code>对代码进行格式化：</p>
<pre><code># 缩进：2个空格，禁用Tab
--indent=spaces=2
# 将注释和下一行代码对齐。
--indent-col1-comments
# &#39;if&#39;, &#39;for&#39;, &#39;while&#39;等代码块前后增加1个空行。
--break-blocks
# 二元操作符两侧增加1个空格。
--pad-oper
# 确保括号两侧无空格。
--unpad-paren
# 确保`*`和`&amp;`靠近类型而不是变量名。
--align-pointer=type --align-reference=type
# 确保&#39;if&#39;, &#39;for&#39;, &#39;while&#39;等代码块如果只有1条语句，依然加花括号。
--add-brackets
# 去掉多行注释每行的`*`前缀。
--remove-comment-prefix
# 在逻辑操作符、逗号、括号、分号或空格处断开，使得每行长度小于80。
--max-code-length=80 --break-after-logical</code></pre>
<p>如果使用的是<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">ClangFormat</a> （现在很多编辑器都支持用ClangFormat），则可将如下<code>.clang-format</code>（可通过 <a href="https://zed0.co.uk/clang-format-configurator/" class="uri">https://zed0.co.uk/clang-format-configurator/</a> 测试效果）放在项目的根目录：</p>
<pre><code>---
Language: Cpp
BasedOnStyle: WebKit

# 不要对#include重排序（人工把握语义）
SortIncludes: false

# 行宽80字节
# ColumnLimit:     80

# 缩进：2个空格
TabWidth: 2
# 命名空间不缩进
NamespaceIndentation: None
# switch里的case缩进一级
IndentCaseLabels: true

# 总是在花括号前换行
BreakBeforeBraces: Allman
# 可选择在非赋值操作符处换行
BreakBeforeBinaryOperators: NonAssignment
# 在需要的情况下才在返回类型处换行（声明与定义）
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
# 对空函数与在类中定义的函数，合并到单行
AllowShortFunctionsOnASingleLine: Inline

# 括号前不加空格
SpaceBeforeParens: Never
# 不要在template关键字后插入空格
# SpaceAfterTemplateKeyword: false

# （多行）函数参数对齐左括号
AlignAfterOpenBracket: Align
# 水平对齐二元或三元操作的操作数
AlignOperands: true
# 对齐连续的赋值
AlignConsecutiveAssignments: true
# 尾部的注释对齐
AlignTrailingComments: true

# 确保`*`和`&amp;`靠近类型而不是变量名。（WebKit风格已设置）
# PointerAlignment: Left
...</code></pre>
<p>由于ClangFormat的命令行自身不支持递归格式化多层目录中的代码，需要自己写脚本（可参考 <a href="https://github.com/eklitzke/clang-format-all/blob/master/clang-format-all">clang-format-all</a> ）或使用编辑器插件自动进行格式化。</p>
<p>由于ClangFormat不支持将注释和下一行代码对齐、二元操作符两侧增加1个空格、确保<code>if</code>/<code>for</code>/<code>while</code>等代码块如果只有1条语句依然加花括号、空行控制等选项，因此不为本编码规范所推荐，但因其应用广泛，亦不反对。</p>
<p><strong>参考</strong></p>
<p><a href="http://llvm.org/docs/CodingStandards.html#introduction">LLVM Coding Standards：Introduction</a>:</p>
<blockquote>
<p>…we explicitly do not want patches that do large-scale reformating of existing code. On the other hand, it is reasonable to rename the methods of a class if you’re about to change it in some other way. Just do the reformating as a separate commit from the functionality change.</p>
</blockquote>
</div>
<div id="f.1-" class="section level3">
<h3><span class="header-section-number">3.5.2</span> F.1 注释</h3>
<p>注释贵精不贵多：</p>
<ul>
<li>注释传递意图(why)，而非做法（how）。</li>
<li>写具备可读性的代码来减少（易于因实现变化而过时的）注释。</li>
<li>内外部API，如公有函数、公有成员等，必须采用Doxygen格式注释。</li>
<li>会被多处使用的实体，如类的静态变量、成员变量、常量、枚举等，必须采用Doxygen格式注释。</li>
</ul>
<p>注释活动应贯穿编码周期始终：</p>
<ul>
<li>新写代码时，应养成先写注释表达意图和思路，再写代码的习惯。</li>
<li>未完成或测试性的代码，应用<code>TODO</code>或者<code>FIXME</code>开头的注释加以说明。</li>
<li>修改代码时，应注意检查相关注释是否依然有效，并进行更新或删减。</li>
<li>不应养成将许多历史代码长期以注释的形态保留的坏习惯。</li>
</ul>
<p>注释格式应清晰可读：</p>
<ul>
<li>类、函数、成员变量等实体，采用Doxygen格式的<code>/** ... */</code>，在实体上方；对于部分字段短小的结构的成员变量等实体，允许在成员同一行的后半段用<code>//</code>注释说明，Doxygen也支持这种格式。</li>
<li>函数体内的一行或一小段代码，采用<code>//</code>开头，空一格后写注释的内容。位置应在代码段上方，反对在代码段后端的写法。</li>
<li>注释应适度进行局部的对齐。</li>
</ul>
<p><strong>例外</strong></p>
<ul>
<li>可以在长段代码块（如类定义、namespace等，特别是有多重嵌套的）尾部的花括号右侧，以<code>//</code>注释说明对应的名称。</li>
<li>在演示性的代码中，允许在行末使用<code>//</code>说明其结果与优劣，本规范的样例，使用该格式。</li>
</ul>
<p><strong>因由</strong></p>
<ul>
<li>过少的注释，他人难以维护，自己几个月后也容易忘记了代码意图与考虑。</li>
<li>过多的注释，难以跟随实现变化，也难以坚持。</li>
<li>先行注释表达意图、思路和待办事项，要比完整正确地用代码实现容易，所以如果写代码时遇到困难陷入细节或者切换上下文去写别处代码，预先写的注释在下次接着写时就能起到很好的提示作用。</li>
<li>格式混乱的注释，影响阅读观感和代码品质。</li>
<li>按照Doxygen格式写的注释，自身整齐清晰，也能自动生成文档，反向促进注释的维护。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
  <span class="co">/**</span>
<span class="co">    关于该类的一行简短描述。</span>

<span class="co">    关于该类的详细描述，如：职责。</span>
<span class="co">  */</span>
  <span class="kw">class</span> ClassName
  {
  <span class="kw">public</span>:

    <span class="co">/**</span>
<span class="co">      关于该函数的一行简短描述。</span>

<span class="co">      关于该函数的详细描述，如：参数、行为和异常处理。</span>

<span class="co">      详见D.4</span>

<span class="co">      </span><span class="an">@param</span><span class="co"> </span><span class="cv">foo</span><span class="co"> 参数foo的意义、用法、取值限制等。</span>

<span class="co">      </span><span class="an">@returns</span><span class="co"> 返回值的说明。如果显然，可忽略。</span>
<span class="co">    */</span>
    <span class="kw">virtual</span> <span class="dt">int</span> anExampleMethod(<span class="dt">int</span> foo);

    <span class="co">/**</span>
<span class="co">      对于废弃的成员函数，应标注:</span>

<span class="co">      </span><span class="an">@deprecated</span>

<span class="co">      并说明原因和替代它的函数。</span>

<span class="co">      </span><span class="an">@see</span><span class="co"> anExampleMethod</span>

<span class="co">      可以适当标注一些TODO事项，按如下格式：</span>

<span class="co">      </span><span class="al">TODO</span><span class="co"> 在下一个major版本移除该方法。</span>
<span class="co">    */</span>
    <span class="dt">void</span> aDeprecatedMethod();

  <span class="kw">private</span>:
    <span class="co">/**</span>
<span class="co">      关于该成员变量的描述</span>
<span class="co">    */</span>
    <span class="dt">int</span> <span class="va">m_anExampleDataMember</span>;

  }; <span class="co">// class ClassName</span></code></pre></div>
<p><strong>参考</strong></p>
<p>在使用Doxygen格式写文档时，可以参考如下约定：</p>
<ul>
<li>基础</li>
<li>启用<code>JAVADOC_AUTOBRIEF</code>选项，这样每个文档注释的首行，就成为该方法的简介</li>
<li>上述方法简介，应使用句号结尾，并用一个空行与其他注释隔开</li>
<li>使用 <code>@</code> to 作为 <a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html">Doxygen命令</a>的前缀，而非 <code>\</code></li>
<li>文档注释依然需要遵循F.3 行宽的规定</li>
<li><code>@param</code> 和 <code>@returns</code> 的文档
<ul>
<li>可以不用句号结尾</li>
<li>每个应新起一行，有整齐的缩进</li>
<li>对出参使用<code>@param[out]</code></li>
<li>参数的文档与返回值的文档中，应用一个空行隔开</li>
<li>对于返回 <code>bool</code>的简单的方法，可以不用提供冗余的文档，直接用<code>@returns</code>说明返回值</li>
</ul></li>
<li>进阶</li>
<li>可以使用Doxygen的<a href="http://www.stack.nl/~dimitri/doxygen/manual/grouping.html#memgroup">Member Groups</a> 特性来为方法分组</li>
<li>可以使用如下好用的Doxygen命令：
<ul>
<li><code>@name</code>、<code>@{</code> 和 <code>@}</code> ：分组</li>
<li><code>@a</code> ：交叉引用参数</li>
<li><code>@c</code> ：交叉引用类型</li>
<li><code>@code{.cpp}</code> ：在文档中给出代码样例</li>
<li><code>@note</code> ：说明注意事项</li>
<li><code>@todo</code> ：说明待办事项，可以生成待办事项列表</li>
<li><code>@internal</code>：避免一些过时的注释出现在文档中</li>
</ul></li>
</ul>
</div>
<div id="f.2-include" class="section level3">
<h3><span class="header-section-number">3.5.3</span> F.2 <code>#include</code></h3>
<p><code>#include</code>天生有序：</p>
<ul>
<li><code>#include</code>应出现在代码的最前面，中间不应穿插其他代码，除了条件编译和头文件保护符。</li>
<li><code>#include</code>应遵循如下顺序：</li>
<li>本定义文件对应的头文件（仅适用于定义文件，详见SF.2）</li>
<li>C标准库的头文件</li>
<li>C++标准库的头文件</li>
<li>操作系统/第三方库的头文件</li>
<li>本项目的头文件</li>
</ul>
<p>最小依赖原则：</p>
<ul>
<li><code>#include</code>应只包含最小必要的头文件。</li>
<li><code>.h</code>文件中，能用前向声明解决的，就不要<code>#include</code>。</li>
<li>不应用一个类似<code>common_include.h</code>的文件来间接包含项目的普遍依赖项，并在每一个头文件中包含它。这样做会放大依赖，引入未知的依赖问题，且降低编译速度。</li>
</ul>
<p>正确区分使用<code>&lt;&gt;</code>和<code>&quot;&quot;</code>：</p>
<ul>
<li>用 <code>#include &lt;filename.h&gt;</code> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</li>
<li>用<code>#include &quot;filename.h&quot;</code> 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。</li>
</ul>
<p><strong>因由</strong></p>
<ul>
<li>包含顺序：消除隐性依赖</li>
<li>最小依赖：提升编译速度</li>
<li><code>&lt;&gt;</code>和<code>&quot;&quot;</code>：消除隐性路径问题</li>
</ul>
<p><strong>样例</strong></p>
<p><code>foo/server/fooserver.cpp</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;foo/server/fooserver.h&quot;</span>

<span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span>

<span class="pp">#include </span><span class="im">&lt;hash_map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;vector&gt;</span>

<span class="pp">#include </span><span class="im">&quot;base/basictypes.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;base/commandlineflags.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;foo/server/bar.h&quot;</span></code></pre></div>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">Google C++ Style Guide: Names and Order of Includes</a></li>
<li><a href="http://llvm.org/docs/CodingStandards.html#include-style">LLVM Coding Standards: <code>#include</code> Style</a></li>
</ul>
</div>
<div id="f.3-" class="section level3">
<h3><span class="header-section-number">3.5.4</span> F.3 行宽</h3>
<p>80字节。</p>
<p><strong>因由</strong></p>
<ul>
<li>这是最广泛采用的标准，少量增加（如90）并无意义，只会带来不一致。</li>
<li>虽然现在宽屏已普及，但需要考虑代码对比时，新老文件左右并列显示时依然能完整显示一行。</li>
<li>短的行宽，能够自然抑制3层以上的深度嵌套。</li>
</ul>
<p><strong>参考</strong></p>
</div>
<div id="f.4-" class="section level3">
<h3><span class="header-section-number">3.5.5</span> F.4 缩进</h3>
<ul>
<li>一致地使用4个或2个空格，禁用Tab。</li>
<li>有层次结构的地方，均应正确缩进，但namespace自身不缩进，也不增加其内部结构的缩进。</li>
</ul>
<p><strong>因由</strong></p>
<p>主要是为了代码一致的可读性。</p>
<ul>
<li>禁用Tab，尤其禁用Tab和空格混用，不禁用的后果是各种编辑器一打开，不同人写的代码就乱套了。</li>
<li>建议不采用浪费空间的4、8个空格，而是紧凑的2个空格，控制行宽。本规范其他地方的样例均采用2个空格。</li>
<li>缩进可以清晰传递层次结构信息，错误的缩进会误导、扭曲语义。</li>
<li>namespace如果缩进，会带来过深的缩进，所以规避之。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> outer {

<span class="kw">namespace</span> inner {           <span class="co">// 良好的风格：namespace自身不缩进</span>


<span class="dt">void</span> foo() {                <span class="co">// 良好的风格：不因在namespace内而增加缩进深度</span>
  ...
}

}  <span class="co">// namespace inner       // 良好的风格：在尾部的花括号注释说明对应的namespace</span>

}  <span class="co">// namespace outer    </span></code></pre></div>
<p>另外一种namespace自身不缩进的写法：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> outer { <span class="kw">namespace</span> inner {  <span class="co">// 良好的风格：namespace自身不缩进，多层合并一行</span>

<span class="dt">void</span> foo() {                         <span class="co">// 良好的风格：不因在namespace内而增加缩进深度</span>
  ...
}

} } <span class="co">// namespace outer::inner        // 良好的风格：在尾部的花括号注释说明对应的多层namespace</span></code></pre></div>
<p><strong>参考</strong></p>
<p>关于namespace：</p>
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Namespace_Formatting">Google C++ Style Guide: Namespace Formatting</a></li>
<li><a href="http://llvm.org/docs/CodingStandards.html#namespace-indentation">LLVM Coding Standards: Namespace Indentation</a></li>
</ul>
</div>
<div id="f.5-" class="section level3">
<h3><span class="header-section-number">3.5.6</span> F.5 括号</h3>
<p>花括号：</p>
<ul>
<li>严禁无花括号的<code>if</code>/<code>else</code>/<code>for</code>/<code>while</code>等语句。</li>
<li>一致地使用花括号换行风格，详见贯彻手段。建议选择其中的“K &amp; R”风格或“break”风格。</li>
</ul>
<p>圆括号：</p>
<ul>
<li>当操作符优先级可能有疑问时（尤其是算术类、逻辑类、其他类等2种以上操作符混合时），使用圆括号明确表达优先级。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span>(a &amp; flag != <span class="dv">0</span>) {}   <span class="co">// 不良的例子：未正确理解优先级，代码运行不符合预期</span>

<span class="cf">if</span>((a &amp; flag) != <span class="dv">0</span>) {} <span class="co">// 良好的例子：通过括号确立优先级，确保正确性和可读性</span>

<span class="cf">if</span>(aCondition) doSomething(); <span class="co">// 不良的例子：无花括号的`if`语句</span>

<span class="co">/*</span>
<span class="co">  良好的例子：只有一行，也要有花括号。</span>
<span class="co">*/</span>
<span class="cf">if</span>(aCondition)
{
  doSomething();
}</code></pre></div>
<p><strong>贯彻手段</strong></p>
<p>通过Astyle（见F.0）的<code>--style</code>选项。几个主要的选择：</p>
<p><code>--style=attach</code>：下称“attach”风格。</p>
<p>开花括号向前跟随，闭花括号后若有类似<code>else</code>等语句则向后跟随，均间隔1个空格。Java社区主流。例如：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> Foo(<span class="dt">bool</span> isBar) {
  <span class="cf">if</span>(isBar) {
    bar();
    <span class="cf">return</span> <span class="dv">1</span>;
  } <span class="cf">else</span> {
    <span class="cf">return</span> <span class="dv">0</span>;
  }
}</code></pre></div>
<p><code>--style=break</code>：下称“break”风格。</p>
<p>开、闭花括号都在单独一行。C++社区较常见。例如：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> Foo(<span class="dt">bool</span> isBar)
{
  <span class="cf">if</span>(isBar)
  {
    bar();
    <span class="cf">return</span> <span class="dv">1</span>;
  }
  <span class="cf">else</span>
  {
    <span class="cf">return</span> <span class="dv">0</span>;
  }
}</code></pre></div>
<p><code>--style=kr</code>：即“K &amp; R”风格，R代表的Dennis Ritchie是C之父，K &amp; R是《The C Programming Language》的作者。</p>
<p>仅对于命名空间、类和函数定义，采用“break”风格；其他均采用“attach”风格。</p>
<p><code>--style=stroustrup</code>：即“Stroustrup”风格，他是C++之父，也是《The C++ Programming Language》的作者。</p>
<p>仅对于函数定义，采用“break”风格；其他均采用“attach”风格。</p>
<p><strong>参考</strong></p>
<p>圆括号：</p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es41-if-in-doubt-about-operator-precedence-parenthesize">CCG ES.41: If in doubt about operator precedence, parenthesize</a></li>
</ul>
</div>
<div id="f.6-" class="section level3">
<h3><span class="header-section-number">3.5.7</span> F.6 换行与空行</h3>
<p>合理使用换行：</p>
<ul>
<li>一行代码只做一件事情，如只定义一个变量，或只写一条语句，或开启一个逻辑块（如函数头、for、if等），便于阅读代码和添加注释。</li>
<li>长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符），并进行适当的缩进，使排版整齐，语句可读。</li>
</ul>
<p>一致而适度地使用空行，划分逻辑单元，增强代码可读性：</p>
<ul>
<li>每个独立实体（类、函数）前后应有空行。</li>
<li>函数体内逻辑关系密切的代码间不加空行，逻辑段落间应有空行。</li>
</ul>
<p><strong>样例</strong></p>
<p>良好的风格：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> aVariable = <span class="dv">123</span>;

<span class="cf">if</span>(aCondition)
{
  doSomethingWith(aVariable);
}

<span class="co">// 打开冰箱门</span>
openFridge();
<span class="co">// 塞进大象</span>
putInElephant();
<span class="co">// 关闭冰箱门</span>
closeFridge();

<span class="cf">if</span>((veryLongVariable1 &gt;= veryLongVariable2)
  &amp;&amp; (veryLongVariable3 &gt;= veryLongVariable4)
  &amp;&amp; (veryLongVariable5 &gt;= veryLongVariable6))
{
  doSomething();
}</code></pre></div>
<p><strong>参考</strong></p>
<p>*《高质量C++/C 编程指南》规则2-2-1、2-2-2、2-5-2</p>
</div>
<div id="f.7-" class="section level3">
<h3><span class="header-section-number">3.5.8</span> F.7 空格</h3>
<p>一致而适度地使用空格，突出关键内容，增强代码可读性。详见样例。</p>
<p><strong>因由</strong></p>
<ul>
<li>如果在满足语法的基础上不加任何空格，代码就显得过于密集，难以清晰抓住关键点。</li>
<li>如果过度使用空格，就像一段话全都加重黑体，反而更加没有重点。</li>
<li>如果空格使用在一个文件内甚至一行内不一致，充满随意性，缺乏对称性，阅读起来就十分别扭，其代码传递的是一种不修边幅、得过且过的气息，不能传递认真谨慎、精益求精的精神。</li>
</ul>
<p><strong>样例</strong></p>
<p>函数、关键字与参数：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  良好的风格：</span>

<span class="co">  * 函数名后不留空格。</span>
<span class="co">  * 左右括号的内外都紧挨，不留空格。</span>
<span class="co">  * 逗号、分行向前紧跟，不留空格。</span>
<span class="co">  * 逗号后留空格。</span>

<span class="co">  因由：</span>

<span class="co">  * 函数名的定义和调用，都应在视觉上将函数名和被操作的参数关联起来，空格则在括号的基础上进一步制造了距离，所以函数名后、左右括号的内外都不应添加空格。</span>
<span class="co">  * 逗号视觉上不应该突出，所以不能是两边空格；没有空格过于紧凑不利于阅读；逗号靠近后面参数会造成后一个参数以逗号开头的奇怪感觉；综上所以逗号更适宜跟随前面一个参数。</span>
<span class="co">*/</span>
<span class="dt">void</span> fun(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> z); <span class="co">// 良好的风格</span>

<span class="co">/*</span>
<span class="co">  不良的风格：</span>

<span class="co">  * 函数名后有多余的空格，造成函数名和参数之间的割裂感。</span>
<span class="co">  * 第一个逗号后无空格，没有合理分隔不同的参数。</span>
<span class="co">  * 第二个逗号前有多余空格，两边的距离把（不重要的）逗号突出出来了。</span>
<span class="co">*/</span>
<span class="dt">void</span> fun (<span class="dt">int</span> x,<span class="dt">int</span> y , <span class="dt">int</span> z);

<span class="co">/*</span>
<span class="co">  良好的风格：</span>

<span class="co">  * for、if等关键词后面不建议加空格（存在争议，有人推荐加）</span>
<span class="co">  * 如果‘;’不是一行的结束符号，其后要留空格，遵循和函数参数里逗号类似的规则。</span>
<span class="co">*/</span>
<span class="cf">for</span>(i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i)

<span class="co">/*</span>
<span class="co">  不良的风格：太少的空格</span>
<span class="co">*/</span>
<span class="cf">for</span>(i=<span class="dv">0</span>;i&lt;<span class="dv">10</span>;i++)</code></pre></div>
<p>操作符相关：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span>(year &gt;= <span class="dv">2000</span>)       <span class="co">// 良好的风格：二元操作符前后加空格</span>
<span class="cf">if</span>((a&gt;=b) &amp;&amp; (c&lt;=d))   <span class="co">// 良好的风格：突出关键的二元操作符，保持整体紧凑</span>
<span class="cf">if</span>(year&gt;=<span class="dv">2000</span>)         <span class="co">// 不良的风格：二元操作符前后无空格，过于密集</span>
<span class="cf">if</span>(year &gt;=<span class="dv">2000</span>)        <span class="co">// 糟糕的风格：没有一致地使用空格，非常别扭</span>

<span class="dt">int</span>* x = &amp;y;           <span class="co">// 良好的风格：一元操作符前后不应加空格</span>
<span class="dt">int</span>* x = &amp; y;          <span class="co">// 不良的风格：空格割裂了一元操作符和被操作对象之间的关系</span>

<span class="co">/*</span>
<span class="co">  推荐的风格：确保`*`和`&amp;`靠近类型而不是变量名</span>
<span class="co">*/</span>
<span class="dt">int</span>* x = NULL;
<span class="dt">void</span> fun(<span class="dt">int</span>* param) {}

<span class="co">/*</span>
<span class="co">  不建议的风格：</span>

<span class="co">  - 如果`*`和`&amp;`在中间，割裂了其和类型的关系</span>
<span class="co">  - 如果`*`和`&amp;`靠近变量名，更像是对变量的操作，而事实并不是</span>
<span class="co">*/</span>
<span class="dt">int</span> * x = NULL;
<span class="dt">int</span> *x = NULL;
<span class="dt">void</span> fun(<span class="dt">int</span> * param) {}
<span class="dt">void</span> fun(<span class="dt">int</span> *param) {}

<span class="co">/*</span>
<span class="co">  象“［］”、“.”、“-&gt;”这类操作符前后不加空格。</span>
<span class="co">*/</span>
array[<span class="dv">5</span>] = <span class="dv">0</span>; <span class="co">// 不要写成 array [ 5 ] = 0;</span>
a.method(); <span class="co">// 不要写成 a . method();</span>
b-&gt;method(); <span class="co">// 不要写成 b -&gt; method();</span></code></pre></div>
<p>注释：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 注释      // 良好的风格： `//`后空一格</span>
<span class="dt">int</span> x = <span class="dv">1</span>;

<span class="co">//注释       // 不良的风格： `//`后紧跟注释</span>
<span class="dt">int</span> x = <span class="dv">1</span>;

<span class="co">/*</span>
<span class="co">  注释       // 良好的风格： `/**`当行无注释，下一行缩进一级（即2个空格）后，开始注释。</span>
<span class="co">*/</span></code></pre></div>
<p><strong>参考</strong></p>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#nl15-use-spaces-sparingly">CCG NL.15: Use spaces sparingly</a></p>
<p>讨论：是否应该用空格来突出<code>if</code>等条件判断场景下的<code>!</code>？因为<code>!</code>非常贴近后面表达式，非常容易看漏。</p>
<p>结论：可以考虑，但可能更应该通过语法高亮和字体等方式来做。</p>
</div>
</div>
<div id="source-file" class="section level2">
<h2><span class="header-section-number">3.6</span> 源文件代码组织(Source File)</h2>
<div id="sf.1-header-file" class="section level3">
<h3><span class="header-section-number">3.6.1</span> SF.1 头文件（Header File）</h3>
<p>头文件是脸面。</p>
<ul>
<li>头文件的内容，包括自身的<code>#include</code>，应被头文件保护符(header guard, i.e. <code>ifndef/define/define</code>）所环绕，防止文件被重复包含，具体格式见样例。</li>
<li>头文件应更少暴露实现细节，如使用<a href="https://en.wikipedia.org/wiki/Opaque_pointer">“Pimpl”惯用法</a>或<a href="https://zh.wikipedia.org/zh-cn/前向声明">前向声明（Forward Declaration）</a>。</li>
<li>头文件应视为对外API或对内API，使用Doxygen格式进行注释，自动生成文档，详见F.1一节。</li>
<li>一致地使用<code>.h</code>或<code>.hpp</code>作为C++头文件的文件名后缀。建议使用最普遍的<code>.h</code>。</li>
<li>注意考虑F.2中提到的关于<code>#include</code>的规则。</li>
</ul>
<p><strong>样例</strong></p>
<p>头文件保护符，遵循<code>项目或总命名空间_关键路径_文件名_H_</code>的格式（注意最后一个下划线），并在<code>#endif</code>处用注释这是保护符的结尾：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="pp">#define FOO_BAR_BAZ_H_</span>

...

<span class="pp">#endif  </span><span class="co">// FOO_BAR_BAZ_H_</span></code></pre></div>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#The__define_Guard">Google C++ Style Guide: The <code>#define</code> Guard</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf-source-files">CCG: Source files</a></li>
</ul>
</div>
<div id="sf.2-definition-file" class="section level3">
<h3><span class="header-section-number">3.6.2</span> SF.2 定义文件（Definition File）</h3>
<p>定义文件是实现。</p>
<ul>
<li>定义文件应包含定义其接口的头文件，参见<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf5-a-cpp-file-must-include-the-h-files-that-defines-its-interface">CCG SF.5</a></li>
<li>将大多数不必要的<code>#include</code>和声明都移到定义文件里来。</li>
<li>反对使用文件作用域变量，其初始化时机存在不确定性，带来潜在顺序依赖。（TODO 找到依据文献）</li>
<li>一致地使用<code>.cpp</code>、<code>.cxx</code>或<code>.cc</code>作为C++定义文件的文件名后缀。建议使用最普遍的<code>.cpp</code>。</li>
<li>注意考虑F.2中提到的关于<code>#include</code>的规则。</li>
<li>如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。头文件一般放在<code>include</code>目录，定义文件一般放在<code>src</code>或<code>source</code>目录。</li>
</ul>
<p><strong>参考</strong></p>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf-source-files">CCG: Source files</a></p>
</div>
</div>
<div id="naming" class="section level2">
<h2><span class="header-section-number">3.7</span> 命名(Naming)</h2>
<div id="n.0-" class="section level3">
<h3><span class="header-section-number">3.7.1</span> N.0 命名一般规范</h3>
<p>命名应“名正言顺”，对被命名者，进行易于理解、结构规范、具体而简洁地描述：</p>
<ul>
<li>易于理解：</li>
<li>命名应使用英文名，不应使用汉语拼音。</li>
<li>对于常见的业务对象命名，应该在设计阶段就给出一致的英文名，避免在代码的不同地方以近义词进行不一致的命名。</li>
<li>命名不允许出现单词拼写错误和语义错误，可以查词典，也可以在<a href="http://unbug.github.io/codelf/">codelf</a>搜索建议的命名，以及参考开源代码中实际使用的命名。</li>
<li>结构规范：</li>
<li>类型、变量、常量等实体性质的命名，一般可采用“形容词/限定词-名词”的结构。</li>
<li>函数等动作性质的命名，一般可采取“动词-名词”的结构。</li>
<li>布尔类型的变量或函数，应使用“is/has/can/should”等前缀，与其后的“形容词/名词/动词”搭配，表达其语义，反对以<code>b</code>作为前缀。</li>
<li>具体：</li>
<li>命名中应避免模糊抽象随意，如<code>data2</code>、<code>object</code>。</li>
<li>替代旧函数<code>fun()</code>的新函数命名，不应将新函数命名为<code>funNew()</code>或<code>newFun()</code>，而应将老的命名为<code>deprecatedFun()</code>，新函数直接用<code>fun()</code>；如果不方便做到，那么新函数命名应充分表达出与老函数的语义区别。</li>
<li>简洁：</li>
<li>命名应使用1-5个英文单词，每个单词宜小于12个字母。</li>
<li>但不要为了简短，就任意缩减字母或采用并非众所周知的缩写。</li>
<li>无歧义：</li>
<li>命名应不易产生误会、歧义或者具备和实际含义相左的字面意思。</li>
<li>反对为了命名的不重复，而选择区别不明显的近义词表达有本质区别的两样事物，如：用<code>fail</code>和<code>error</code>表达业务错误和系统错误的区别，容易导致使用者记混用错。</li>
<li>反对用一个名字表达多重意思，如：一个类里多个成员函数都用<code>add</code>前缀，表示的却是统计累加、队列添加、记录添加等不同意思。</li>
<li>反对用多个名字表达一个意思，如在代码里不同地方，以不同的名字称呼同一个事物，从而导致阅读者和使用者揣测其微妙区别。</li>
</ul>
<p><strong>例外</strong></p>
<p>作用域非常小，而含义因周围代码而较明显时，可使用短小命名。</p>
<p>参见<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es7-keep-common-and-local-names-short-and-keep-uncommon-and-nonlocal-names-longer">CCG ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer</a></p>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  良好的风格</span>
<span class="co">*/</span>
<span class="kw">class</span> Animal;

Animal goodDog;

goodDog.run();
goodDog.eatFood();

<span class="dt">bool</span> isRunning = goodDog.isRunning();

<span class="co">/*</span>
<span class="co">  不良的风格：使用拼音</span>
<span class="co">*/</span>
<span class="kw">class</span> dongWu;

<span class="co">/*</span>
<span class="co">  不良的风格：冗长</span>
<span class="co">*/</span>
<span class="dt">int</span> aVeryLongAndComplicatedAndRedundantName;

<span class="co">/*</span>
<span class="co">  不良的风格：拼写错误</span>
<span class="co">*/</span>
Field filed;

<span class="co">/*</span>
<span class="co">  良好的风格，简炼，更易读：</span>

<span class="co">  * 模板类型使用惯见的`T`</span>
<span class="co">  * 循环使用惯见的`i`、`j`、`k`等</span>
<span class="co">*/</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;    <span class="co">// good</span>
<span class="dt">void</span> print(ostream&amp; os, <span class="at">const</span> vector&lt;T&gt;&amp; v)
{
  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.end(); ++i)
  {
    os &lt;&lt; v[i] &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
  }
}

<span class="co">/*</span>
<span class="co">  不良的风格，简单的代码变得冗长：</span>
<span class="co">*/</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> ElementType&gt;
<span class="dt">void</span> print(ostream&amp; target_stream, <span class="at">const</span> vector&lt;ElementType&gt;&amp; current_vector)
{
    <span class="cf">for</span> (<span class="dt">int</span> current_element_index = <span class="dv">0</span>;
            current_element_index &lt; current_vector.end();
            ++current_element_index
    )
    target_stream &lt;&lt; current_vector[i] &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p><strong>参考</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Naming_convention_(programming)">Wikipedia的Naming Convention(programming)条目</a></p>
</div>
<div id="n.1-" class="section level3">
<h3><span class="header-section-number">3.7.2</span> N.1 文件名</h3>
<ul>
<li>一个模块内，如果文件比较多，可以通过目录对文件进行分组，建议1层，不要超过2层。</li>
<li>目录名全部小写，单词间用下划线<code>_</code>相连，一般最好只有1个单词。</li>
<li>文件名全部小写，单词间用下划线<code>_</code>相连。</li>
<li>文件名应具体而非抽象，可以通过文件名了解该文件的功能，但不宜太长。</li>
</ul>
<p><strong>样例</strong></p>
<p>目录名：</p>
<ul>
<li>良好：<code>base</code>、<code>admin</code></li>
<li>不良：<code>Base</code>、<code>some_module</code></li>
</ul>
<p>文件名：</p>
<ul>
<li>良好：<code>http_server_logs.h</code></li>
<li>不良：<code>logs.h</code>、<code>a_handsome_smart_and_great_guy.h</code></li>
</ul>
</div>
<div id="n.2-" class="section level3">
<h3><span class="header-section-number">3.7.3</span> N.2 命名空间</h3>
<ul>
<li>原则上，一个组织/一个子系统应该有自己的顶级命名空间，下设以模块、功能的次级命名空间，建议1层，一般不超过2层。</li>
<li>命名空间的命名规则同文件。</li>
<li>如果使用了目录划分文件，同一目录下的文件的命名空间应一致，要么直接用顶级命名空间，要么次级命名空间和目录名一致。</li>
</ul>
</div>
<div id="n.3-" class="section level3">
<h3><span class="header-section-number">3.7.4</span> N.3 类型命名</h3>
<ul>
<li>类型命名应采用<code>CamelCase</code>的格式，即每个单词首字母大写，其他字母小写，单词间直接相连。</li>
<li>可以考虑使用前缀：</li>
<li>常用的有：类（C，代表class）、结构（S，代表struct）、枚举（E，代表enum）；</li>
<li>不太常用的有：类型定义（T，代表typedef）、联合（U，代表union）。</li>
</ul>
<p><strong>样例</strong></p>
<ul>
<li>良好：<code>Animal</code>、<code>DigitalCamera</code>、<code>CWindow</code></li>
<li>不良：<code>animal</code>、<code>digital_camera</code></li>
</ul>
</div>
<div id="n.4-" class="section level3">
<h3><span class="header-section-number">3.7.5</span> N.4 常量命名</h3>
<ul>
<li>常量包括<code>const</code>定义的常量、枚举值和宏定义的常量。</li>
<li>常量命名应采用<code>UPPER_CASE_UNDERSCORE</code>的格式，即所有字母大写，单词间用下划线<code>_</code>相连。</li>
<li>同一组常量（如一个枚举里的多个枚举值），应有统一前缀。</li>
</ul>
</div>
<div id="n.5-" class="section level3">
<h3><span class="header-section-number">3.7.6</span> N.5 变量命名</h3>
<ul>
<li>变量命名应采用<code>camelCase</code>的格式，即第一个单词首字母小写，其余单词首字母大写，其他字母小写，单词间直接相连。</li>
<li>坚定一致地使用作用域前缀：</li>
<li>成员变量，应采用<code>m_</code>前缀（因此使用时不再需要通过<code>this-&gt;</code>来区分成员变量与参数、局部变量）。注意：该前缀仅适用于非<code>public</code>的成员，因此结构体的成员变量不应有<code>m_</code>前缀。</li>
<li>全局变量，应采用<code>g_</code>前缀（但应规避全局变量）。</li>
<li>静态变量，应该用<code>s_</code>前缀。</li>
<li>全局的共享内存变量，可采用<code>gg_</code>前缀（存在争议）。</li>
<li>具备上述多个作用域的，按照<code>sgm</code>的顺序（符合英语语序）进行结合。</li>
<li>作用域前缀__不__算在<code>camelCase</code>的格式之内。</li>
<li>对于在一定语境内反复出现的业务对象，坚持使用N.0中提到的“形容词/限定词-名词”结构。</li>
</ul>
<p>可选的类型前缀：</p>
<ul>
<li>指针前缀</li>
<li>指针，应该使用<code>p</code>前缀，代表pointer。</li>
<li>函数指针，应该使用<code>pfn</code>前缀，代表function pointer。</li>
<li>可选、适度使用易理解的、简化版的匈牙利命名法，如：</li>
<li>整数（<code>n</code>，代表number）</li>
<li>无符号整数（<code>ui</code>，代表unsigned integer）</li>
<li>C风格字符串（<code>sz</code>，代表string ends with zero）</li>
<li>C++风格字符串（<code>str</code>，代表string）</li>
<li>存在争议项：</li>
<li>结构类型的变量，可采用<code>st</code>前缀。</li>
<li>对于在一定语境内反复出现的基础对象，使用易于领会的类型缩写前缀，比如：可以用<code>vec/set/map/hash</code>等前缀，代表<code>std::vector/std::set/std::map/std::unordered_map</code>等STL容器类型）。</li>
<li>类型前缀算在<code>camelCase</code>的格式之内。</li>
</ul>
<p>注意：作用域前缀永远在类型前缀之前，如一个表达<code>foo</code>这个意思的、类型为函数指针的成员变量，加了作用域前缀和类型前缀后应命名为<code>m_pfnFoo</code>。</p>
</div>
<div id="n.6-" class="section level3">
<h3><span class="header-section-number">3.7.7</span> N.6 函数命名</h3>
<ul>
<li>函数命名应采用如下两种格式之一：</li>
<li><code>CamelCase</code>的格式，即每个单词的首字母都__大写__，其他字母小写，单词间直接相连。</li>
<li><code>camelCase</code>的格式，即第一个单词首字母__小写__，其余单词首字母大写，其他字母小写，单词间直接相连。</li>
<li>对于操作类的函数，坚持使用N.0中提到的“动词-名词”结构。</li>
<li>对于访问和修改类的函数，应分别使用<code>get</code>和<code>set</code>前缀（首字母的大小写和其他函数保持一致），其中访问类函数的<code>get</code>可以略去，但需要在一个类里乃至一个代码基里对此保持一致。访问类函数应声明为<code>const</code>，见FB.1。</li>
<li>对于返回布尔值的函数，应使用N.0中提到的“is/has/can/should”前缀。</li>
</ul>
</div>
</div>
<div id="basics" class="section level2">
<h2><span class="header-section-number">3.8</span> 基础编码（Basics）</h2>
<div id="b.0-" class="section level3">
<h3><span class="header-section-number">3.8.1</span> B.0 防御性编程</h3>
<p>一段代码应通过校验确保前置条件满足，才执行主体逻辑，并校验后置条件满足，尤其是对于一个函数、一个类、一个模块而言。</p>
<p>代码的假设与依赖，应该通过上述校验来清晰表达出来，不应隐含地引入，或只在注释中说明。</p>
<p><strong>因由</strong></p>
<p>不能因为如下理由而不坚持防御性编程：</p>
<ol style="list-style-type: decimal">
<li>该条件（恒等式）显然/必然成立</li>
<li>过早考虑性能因素</li>
<li>觉得此类检查/保障在调用者和被调用者处重复，从而多余</li>
</ol>
<p>因为：</p>
<ol style="list-style-type: decimal">
<li>需求的变化会威胁恒等式的成立，甚至迫使我们寻找新的恒等式；技术的错误（如内存覆盖）可能从意想不到的角度破坏其成立。</li>
<li>在这段代码的性能问题成为问题之前，其可维护性问题、运行异常定位就会先频频成为问题。而且，<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p4-ideally-a-program-should-be-statically-type-safe">类型检查</a>、静态断言等<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p5-prefer-compile-time-checking-to-run-time-checking">编译期检查机制</a>，可以在不影响运行性能的情况下，防止很多条件的违反。而运行时检查，可以先遵循<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p6-what-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time">CCG P.6</a>和<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#p7-catch-run-time-errors-early">CCG P.7</a>，待真正需要优化性能时，总是有办法可以优化的。</li>
<li>多余的问题可以从3个方面考虑：</li>
</ol>
<ul>
<li>被调用者应被视为一个自足的、会自我保护的主体来看待，它可能被很多并不做检查的调用者调用。</li>
<li>调用者通过检查前一步的后置条件来保护被调用者，被调用者通过检查本步骤的前置条件保护自己，这是一种分工。</li>
<li>一个系统真正出现引起损失的问题，往往是多个环节都存在缺失。为了一个系统的健壮和对疏失具备一定的抵抗力，适度的冗余是必要的。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">void</span> handle(<span class="at">const</span> InputType&amp; in)
{
  <span class="co">// 检查输入参数</span>
  checkInput(in);

  <span class="co">// 检查前置条件，state代指某个状态</span>
  checkPreCondition(state);

  <span class="co">// 执行操作</span>
  OutputType out = op(state);

  <span class="co">// 检查后置条件</span>
  checkPostCondition(state);

  <span class="cf">return</span> out;
}</code></pre></div>
</div>
<div id="b.1-" class="section level3">
<h3><span class="header-section-number">3.8.2</span> B.1 合理使用配置</h3>
<p>首先反对将代码运行依赖的一些参数写死在代码里，以至于每次调整都必须修改代码。应有一种配置的意识，始终为各种参数提供修改配置即可调整的可能。</p>
<p>配置应提供方便的调整手段：</p>
<ul>
<li>配置文件应考虑热加载。</li>
<li>部分可能经常在运行时调整的参数（如限流阈值），应提供接口方式热修改（如发个管理命令UDP包）。与此同时，应通过合理方案确保程序重启后依然生效。</li>
</ul>
<p>通过“约定优先于配置”的思路，避免配置的无限膨胀和误配：</p>
<ul>
<li>提供合理的、符合直觉并具备一致性的默认值，减少配置的数量和冗余。</li>
<li>通过尽可能少的配置项决定配置参数的组合，避免相互耦合却需要分别配置的配置项。</li>
<li>有默认约定不是不要配置，要在默认值的基础上通过配置预留深度定制的空间。</li>
<li>配置项名称应包含单位（如秒、毫秒），配置项应有注释。</li>
<li>同一项目的配置项命名应采取一致的大小写规则，如<code>ALL_CAPS</code>、<code>under_score</code>等，不建议采取大小写混用的格式，因为容易记错。</li>
</ul>
</div>
<div id="b.2-" class="section level3">
<h3><span class="header-section-number">3.8.3</span> B.2 严禁使用幻数</h3>
<p>幻数（Magic Number）又称魔数，指代码中出现的含义模糊、依据缺失的裸数字。</p>
<p>程序中使用的每一个数字，应该以枚举或常量的方式定义，通过名称清晰地揭示其含义与单位，通过表达式揭示起推算过程，通过注释进一步加以说明，并在局部相对集中的地方定义（比如一个子模块里有一个文件定义子模块公共常量，整个项目也有一个文件定义项目公共常量）。</p>
<p><strong>因由</strong></p>
<p>从写代码者的角度：</p>
<p>每到一个需要确定1个数字的场景，都需要决定该数字的取值，从而带来取值的随意性，没有统一的推导依据。</p>
<p>没有依据导致无法应对未考虑到的极端情况，没有一致的依据导致多个幻数间可能只有最短的板生效，其他都带来危险（如溢出）或损失（如截断）。</p>
<p>从读代码者的角度：</p>
<p>难以理解一段代码的意图，更难以确认其正确性和适用范围。</p>
<p>从修改代码者的角度：</p>
<p>需要修改这个幻数的取值时，难以找到和这个幻数同等含义和用场的所有幻数一起修改，极易改漏。</p>
<p><strong>样例</strong></p>
<p>不良的风格：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// </span><span class="al">TODO</span><span class="co"> 补充一段从实际代码基中提取出来的较多依据不一的幻数的代码段。</span></code></pre></div>
<p>良好的风格：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
<span class="co">  默认HTTP连接超时，单位：毫秒。</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">int</span> DEFAULT_HTTP_CONNECT_TIMEOUT_IN_MS = <span class="dv">200</span>;

<span class="co">/**</span>
<span class="co">  每天的秒数。</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">long</span> SECONDS_PER_DAY = <span class="dv">24</span> * <span class="dv">60</span> * <span class="dv">60</span>;

<span class="co">/**</span>
<span class="co">  每个key-value对中的key的大小限制</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">size_t</span> KEY_SIZE = <span class="dv">128</span>;

<span class="co">/**</span>
<span class="co">  每个key-value对中的value的大小限制</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">size_t</span> VALUE_SIZE = <span class="dv">512</span>;

<span class="co">/**</span>
<span class="co">  对value做UrlEncode的缓冲区大小</span>

<span class="co">  依据：最坏的情况下，全部需要encode，1个字节变成&#39;%&#39;+2个字节的HEX值，膨胀系数为3</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">size_t</span> ENCODED_VALUE_SIZE = VALUE_SIZE * <span class="dv">3</span>;

<span class="co">/**</span>
<span class="co">  一个报文的大小限制：10kB</span>
<span class="co">*/</span>
<span class="at">const</span> <span class="dt">size_t</span> PACKET_SIZE = <span class="dv">10</span> * <span class="dv">1024</span>;</code></pre></div>
</div>
<div id="b.3-raii" class="section level3">
<h3><span class="header-section-number">3.8.4</span> B.3 用RAII管理资源的申请与释放</h3>
<p><a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII（Resource Acquisition Is Initialization）</a>是C++防止资源泄漏的一种惯用法（Idiom）。具体而言，RAII使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。</p>
<p>资源包括内存、锁、文件句柄、Socket句柄、数据库结果等。</p>
<p>严禁在业务代码中出现<code>new</code>/<code>delete</code>对、<code>lock</code>/<code>unlock</code>对、<code>open</code>/<code>close</code>对等，应将其用合适的资源管理类封装在内，使得业务代码无需确保其成对出现。</p>
<p>更好的方式应该是复用如下成熟的资源管理类：</p>
<ul>
<li>管理内存：</li>
<li>使用C++11标准库的<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr&lt;T&gt;</code></a>或<a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr&lt;T&gt;</code></a>，参考L.3</li>
<li>使用boost库里对应的<a href="http://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/scoped_ptr.htm"><code>boost::scoped_ptr&lt;T&gt;</code></a>或<a href="http://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/shared_ptr.htm"><code>boost::shared_ptr&lt;T&gt;</code></a>，注意其和C++11标准库的行为的差异</li>
<li>管理锁：</li>
<li>使用C++11标准库的<a href="http://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard&lt;Mutex&gt;</code></a></li>
<li>使用boost库里对应的<a href="http://www.boost.org/doc/libs/1_61_0/doc/html/thread/synchronization.html#thread.synchronization.lock_guard.lock_guard"><code>boost::lock_guard&lt;Lockable&gt;</code></a>，注意其和C++11标准库的行为的差异</li>
</ul>
<p><strong>因由</strong></p>
<p>一般而言，一段代码会有多个出口，比如：</p>
<ul>
<li>某个条件满足，提前return</li>
<li>某个条件满足，循环提前break</li>
<li>某种异常情况，抛出exception</li>
<li>等等等等</li>
</ul>
<p>或者申请多个资源。</p>
<p>无论是1个资源多个出口，还是多个资源1个出口，或是多个资源多个出口，确保每个资源在每个出口处得到正确的释放，十分困难。纵然初次写代码时考虑周全了，也难以在后继修改中确保不遗漏。</p>
<p>对于栈上分配的对象，C++保证无论以何种方式退出当前代码块时，都会调用该对象的析构函数，这就提供了一种减轻编程者心智负担、对代码健壮性加以保障的机制，应对这种机制，加以善用。</p>
<p><strong>样例</strong></p>
<p>不良的风格：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">bool</span> doSomething()
{
  Resource* pRc = acquireResource(<span class="co">/* 初始化资源的参数 */</span>);

  <span class="dt">int</span> result = step1(*pRc);

  <span class="cf">if</span>(result != <span class="dv">0</span>)
  {
    releaseResource(pRc);
    <span class="cf">return</span> <span class="kw">false</span>;
  }

  <span class="co">// 内部可能抛出exception</span>
  step2(pRc-&gt;getSomething());

  releaseResource(pRc);

  <span class="cf">return</span> <span class="kw">true</span>;
}</code></pre></div>
<p>良好的风格：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ResourceGuard
{
  <span class="kw">public</span>:
    ResourceGuard(<span class="co">/* 初始化资源的参数 */</span>)
    {
      <span class="va">m_pRc</span> = acquireResource(<span class="co">/* 初始化资源的参数 */</span>);
    }

    ResourceGuard(Resource* pRc): <span class="va">m_pRc</span>(pRc) {}

    ~ResourceGuard()
    {
      releaseResource(pRc);
    }

    <span class="co">/*</span>
<span class="co">      此处应考虑拷贝构造函数等因素，略</span>
<span class="co">    */</span>

    <span class="co">/*</span>
<span class="co">      此处可以有一系列对资源进行操作的方法，略</span>
<span class="co">    */</span>

  <span class="kw">private</span>:
    Resource* <span class="va">m_pRc</span>;
};


<span class="dt">bool</span> doSomething()
{
  ResourceGuard pRc(<span class="kw">new</span> Resource());

  <span class="dt">int</span> result = step1(*pRc);

  <span class="cf">if</span>(result != <span class="dv">0</span>)
  {
    <span class="cf">return</span> <span class="kw">false</span>;
  }

  <span class="co">// 内部可能抛出exception</span>
  step2(pRc-&gt;getSomething());

  <span class="cf">return</span> <span class="kw">true</span>;
}</code></pre></div>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization">CCG R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership">CCG R.20: Use <code>unique_ptr</code> or <code>shared_ptr</code> to represent ownership</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership">CCG R.21: Prefer <code>unique_ptr</code> over <code>shared_ptr</code> unless you need to share ownership</a></li>
</ul>
</div>
<div id="b.4-" class="section level3">
<h3><span class="header-section-number">3.8.5</span> B.4 防止不必要的范围扩大</h3>
<ul>
<li>严禁全局变量，考虑更小的作用域，或者单例模式能否满足需求。</li>
<li>避免使用友元函数和友元类（<code>friend</code>关键字），考虑调整类之间的关系，而非加大数据暴露。</li>
<li>避免污染全局命名空间：减少<code>using namespace xxx</code>的使用。头文件中禁用，定义文件中优先考虑直接在用时加命名空间前缀，其次考虑使用<code>using xxx::yyy</code>。</li>
<li>局部变量的作用域应尽可能小。</li>
<li>成员变量和成员函数，应尽可能减少可访问它的范围。</li>
<li>可采用如下两种方案之一，区分成员函数调用和全局函数调用：</li>
<li>成员函数调用前不加<code>this-&gt;</code>，全局函数前调用加<code>::</code></li>
<li>成员函数调用前加<code>this-&gt;</code>，全局函数调用直接调用</li>
</ul>
</div>
<div id="b.5-" class="section level3">
<h3><span class="header-section-number">3.8.6</span> B.5 变量应有清晰而唯一的用途</h3>
<ul>
<li>仅在即将初始化和使用时，声明变量。</li>
<li>不应保留未使用的变量。</li>
<li>不应该把1个变量用作多个用途。</li>
</ul>
<p><strong>因由</strong></p>
<blockquote>
<p>Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. —— Antoine de Saint-Exupery</p>
</blockquote>
<p>上面的“take away”不仅代表“去除”，也包含“合并”。</p>
<p>远离初始化和使用的变量声明的坏处：</p>
<ul>
<li>代码可读性下降。</li>
<li>容易引发误用。</li>
</ul>
<p>未使用的变量的坏处：</p>
<ul>
<li>可能它本来是有用的，但用错了别的变量，导致它被漏用。如果养成习惯留着未使用的变量，就难以发现漏用的变量。</li>
<li>它可能与别的变量形似，从而被误用。</li>
</ul>
<p>多用途的变量的坏处：</p>
<ul>
<li>代码可读性下降：多个用途，容易让人难以理解代码意图，尤其是无关用途。</li>
<li>状态残留：同一个变量前一次被使用时的状态，可能因为一些原因未清理干净，从而影响到后一次使用。</li>
<li>资源泄露：指针、句柄类的变量，在复用时，可能导致原来指向的资源未正确释放。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  不良的风格：</span>

<span class="co">  * 没有立刻初始化。</span>
<span class="co">  * 一行声明多个变量，违反F.6</span>
<span class="co">*/</span>
<span class="dt">int</span> i, j, k;
<span class="co">// 100行无关代码</span>
i = <span class="dv">3</span>;
<span class="co">// 100行无关代码</span>
j = <span class="dv">4</span>;
<span class="co">// 100行无关代码</span>
k = i + j;

<span class="co">/*</span>
<span class="co">  不良的风格：代码声明后没有使用。</span>
<span class="co">*/</span>
<span class="dt">int</span> neverUsed;

<span class="co">/*</span>
<span class="co">  不良的风格：一个变量用作多个用途。</span>
<span class="co">*/</span>
ResultType result = step1();
<span class="co">// ...判断result有效并使用的...</span>
result = step2();</code></pre></div>
<p><strong>参考</strong></p>
<ul>
<li>CCG ES.20: Always initialize an object</li>
<li>CCG ES.21: Don’t introduce a variable (or constant) before you need to use it</li>
<li>CCG ES.22: Don’t declare a variable until you have a value to initialize it with</li>
<li>CCG ES.26: Don’t use a variable for two unrelated purposes</li>
</ul>
</div>
<div id="b.6-" class="section level3">
<h3><span class="header-section-number">3.8.7</span> B.6 规避已知编码问题</h3>
<p>不使用可能带来如下编码安全问题的高危函数，使用其更安全的替代者：</p>
<ul>
<li>缓冲区溢出</li>
<li>类型安全</li>
<li>Shell安全</li>
<li>SQL注入、XSS等元字符转义型漏洞</li>
<li>CSRF等跨站型漏洞</li>
<li>线程不安全</li>
<li>参数校验缺失</li>
<li>权限校验缺失</li>
<li>……</li>
</ul>
<p>通过学习吸取前人教训，不重蹈编程反模式的覆辙。</p>
<p><strong>因由</strong></p>
<p>已经广为人知的坑，自己应该知道并规避，不要因为惰怠而付出血泪的代价。</p>
<p><strong>参考</strong></p>
<p>团队应维护自己的高危函数列表，收集时可以参考如下列表：</p>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/bb288454.aspx">MSDN: Security Development Lifecycle (SDL) Banned Function Calls</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/security/buffer-defend/">IBM developerWorks: 使您的软件运行起来: 防止缓冲区溢出</a></li>
<li>Apple Developer Secure Coding Guide：</li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/Articles/TypesSecVuln.html">Types of Security Vulnerabilities</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Security/Conceptual/SecureCodingGuide/SecurityDevelopmentChecklists/SecurityDevelopmentChecklists.html">Security Development Checklists</a></li>
</ul>
<p>反模式：</p>
<ul>
<li><a href="https://cwe.mitre.org/data/index.html">Common Weakness Enumeration (CWE)</a></li>
<li><a href="http://www.sans.org/top25-software-errors/">What Errors Are Included in the Top 25 Software Errors?</a></li>
<li><a href="https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns">Introduction to Software Engineering/Architecture/Anti-Patterns</a></li>
<li><a href="https://en.wikipedia.org/wiki/Anti-pattern#Software_engineering">Wikipedia: Software Engineering Anti-pattern</a></li>
<li><a href="http://sahandsaba.com/nine-anti-patterns-every-programmer-should-be-aware-of-with-examples.html">9 Anti-Patterns Every Programmer Should Be Aware Of</a></li>
<li><a href="https://sourcemaking.com/antipatterns/software-development-antipatterns">Software Development AntiPatterns</a></li>
</ul>
</div>
<div id="b.7-" class="section level3">
<h3><span class="header-section-number">3.8.8</span> B.7 重视警告</h3>
<p>应重视编译器和静态/动态代码检查的警告，及时修正，逐步趋近0容忍。</p>
<p>反对因为缺乏代码质量相关知识，而误认为告警很多是误报或者不是什么大问题。</p>
<p>静态/动态代码检查工具列表：</p>
<ul>
<li><a href="http://cppcheck.sourceforge.net/">Cppcheck</a></li>
<li><a href="http://clang-analyzer.llvm.org/">Clang Static Analyzer</a></li>
<li><a href="http://valgrind.org/">Valgrind</a></li>
</ul>
</div>
</div>
<div id="function-body" class="section level2">
<h2><span class="header-section-number">3.9</span> 函数体代码组织（Function Body）</h2>
<div id="fb.0-" class="section level3">
<h3><span class="header-section-number">3.9.1</span> FB.0 函数应中心明确，语义清晰，详略得当，条理分明</h3>
<p>优美的代码就像一首诗。或者至少，像一篇文章。</p>
<ul>
<li>中心明确：一个函数应该具备高内聚，即围绕一个中心展开，其中心思想，应该能在7-10个字内说清楚，而且不带连词。</li>
<li>语义清晰：代码中应综合运用常量/枚举名、变量/参数名、（被本函数调用的）函数名甚至宏名，将操作对象、操作动作等类似主谓宾的重点要素突出出来，而不是充满底层细节。</li>
<li>详略得当：大致遵循代码重要程度和代码“面积”成正比的原则，避免大量底层细节铺开来形成多行冗长的代码，却让抽象程度更高、更贴近语义和意图、代表着关键步骤环节的代码，被淹没其中。</li>
<li>条理分明：步骤间按符合时间、空间或逻辑的顺序和关系进行组织；步骤间中间结果的承转传递，清晰合理。</li>
</ul>
<p><strong>贯彻手段</strong></p>
<p>先写注释规划代码的关键步骤，再写代码。</p>
</div>
<div id="fb.1-" class="section level3">
<h3><span class="header-section-number">3.9.2</span> FB.1 函数参数</h3>
<p>基本要素：</p>
<ul>
<li>定义函数时，参数顺序为：输入参数在前，输出参数在后。</li>
<li>输入参数对非基本类型应使用<code>const</code>引用。</li>
<li>输出参数应使用非<code>const</code>引用，并与返回值合理搭配，或去掉返回值。</li>
<li>返回值对非基本类型应优先使用<code>const</code>引用，谨慎使用传值或非<code>const</code>引用。</li>
<li>不修改对象成员变量的函数，必须标注为<code>const</code>。</li>
<li>禁止带throw (XXXException)的异常声明。原因：如果函数内抛的异常与指定的异常类型不符，程序会crash，并带来debug的困难。</li>
</ul>
<p>参数组织：</p>
<ul>
<li>一般而言，第1个参数应与函数名的动词，形成“动-宾”结构。</li>
<li>多个参数应按关联度分组，同组的参数放在一起。</li>
<li>避免非常长的参数列表，比如大于10个的参数基本可以确定不合理，此时应将同组的参数合并为一个结构体或类传入。</li>
<li>参数名避免出现意义相同或相似的命名，要能从参数名区分出各个参数的区别和用途。</li>
<li>谨慎使用<code>bool</code>类型的参数，而应优先考虑枚举，获得更清晰的语义和可扩展性，除非：</li>
<li>的确是二元互斥关系</li>
<li><code>bool</code>类型的参数是这个函数的唯一参数</li>
<li>函数名能够表达清楚怎样是<code>true</code></li>
</ul>
</div>
<div id="fb.2-" class="section level3">
<h3><span class="header-section-number">3.9.3</span> FB.2 函数复杂度</h3>
<p>倾向于编写短小、凝练的函数，便于他人阅读和修改代码。</p>
<p>如果函数超过40行，说明这个函数很可能存在潜在设计问题，上下文之间存在隐含的依赖关系，容易产生难以发现的bug。</p>
<p>但也注意，如果过度追求很短的函数，可能带来很深的函数调用层次，同样也会不利于他人阅读和修改代码。所以要寻找深度和长度之间平衡点。</p>
</div>
<div id="fb.3-" class="section level3">
<h3><span class="header-section-number">3.9.4</span> FB.3 主流程函数</h3>
<p>建议在一个子功能的最外层的主流程函数，采取如下方式：</p>
<p>里面只有顺序调用多个步骤函数，每个函数没有入参也没有出参。通过成员变量来传递中间状态和结果。</p>
</div>
<div id="fb.4-ifelse-ifelse" class="section level3">
<h3><span class="header-section-number">3.9.5</span> FB.4 写周全的<code>if/else if/else</code></h3>
<p>对于任何需要通过<code>if</code>判断的代码，应：</p>
<ul>
<li>通过<code>if</code>/<code>else if</code>将所有可能出现的具体情况枚举出来，相应处理。</li>
<li>通过<code>else</code>表达未预料的、不应出现的或默认的情况，相应处理。</li>
</ul>
<p>注意：</p>
<ul>
<li>每一个分支都应该加以处理，如果实在无需处理或理应忽略，也应注释说明，不能留空。</li>
<li><code>else</code>分支，可考虑报错、抛异常、中断循环、上报统计、发送告警、打日志并忽略、默认逻辑等处置方式。</li>
<li>避免使用有“且”、“或”的条件。如果要使用，需要十分仔细地分析其他的<code>else if</code>分支有没有不小心漏数了一些情况。</li>
</ul>
<p>反对：</p>
<ul>
<li>多层嵌套无<code>else</code>甚至无<code>else if</code>的裸<code>if</code>块。</li>
<li><code>if</code>了一个具体情况，<code>else</code>了其他所有。</li>
</ul>
<p><strong>例外</strong></p>
<p>允许不写周全的<code>if/else if/else</code>的情况：</p>
<ul>
<li>专用于异常情况或终止条件处理的短路<code>if</code>块。</li>
<li>专用于可选步骤的<code>if</code>块，应通过注释标明“可选步骤”这个语义。该例外不可滥用。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  良好的风格：</span>

<span class="co">  * 枚举每种情况，对未能枚举的情况，给出了针对性处理。</span>
<span class="co">  * 被比较的常量在==的前方，防止误将==写成=</span>
<span class="co">*/</span>
<span class="cf">if</span>(CONDITION1 == value)
{
  <span class="co">// 处理CONDITION1</span>
}
<span class="cf">else</span> <span class="cf">if</span>(CONDITION2 == value)
{
  <span class="co">// 处理CONDITION2</span>
}
<span class="cf">else</span>
{
  <span class="co">// 未预料的、不应出现的或默认的情况</span>
  <span class="cf">throw</span> XXXException(<span class="st">&quot;出错的信息&quot;</span>);
}

<span class="co">/*</span>
<span class="co">  良好的风格：专用于异常情况或终止条件处理的短路`if`块</span>
<span class="co">*/</span>
<span class="cf">while</span>(<span class="co">/* 控制主循环条件 */</span>)
{
  <span class="cf">if</span>(<span class="co">/* 循环结束的另一条件 */</span>)
  {
    <span class="cf">break</span>;
  }
  <span class="co">// ...</span>
}

<span class="dt">int</span> fun(<span class="dt">int</span> input)
{
  <span class="cf">if</span>(input &lt;= <span class="dv">0</span>)
  {
    <span class="cf">throw</span> XXXException(<span class="st">&quot;input必须大于0&quot;</span>);
  }

  <span class="dt">int</span> ret = input + <span class="dv">1</span>;

  <span class="cf">return</span> ret;
}

<span class="co">/*</span>
<span class="co">  良好的风格： 专用于可选步骤的`if`块，通过注释标明“可选步骤”这个语义。</span>
<span class="co">*/</span>
<span class="dt">void</span> fun()
{
  mandatoryStep1();

  mandatoryStep2();

  <span class="co">// 可选：仅当XXX时</span>
  <span class="cf">if</span>(condition)
  {
    optionalStep();
  }

  mandatoryStep3();
}

<span class="co">/*</span>
<span class="co">  不良的风格：</span>

<span class="co">  * 多层裸`if`</span>
<span class="co">  * 被比较的常量在==的后方，容易误将==写成=而难以察觉</span>
<span class="co">*/</span>
<span class="cf">if</span>(value1 == CONST1)
{
  <span class="co">// 某些动作1</span>
  <span class="cf">if</span>(value2 == CONST2)
  {
    <span class="co">// 某些动作2</span>
    <span class="cf">if</span>(value3 == CONST3)
    {
      <span class="co">// 某些动作3</span>
    }
  }
}

<span class="co">/*</span>
<span class="co">  不良的风格：情况枚举时使用了复杂的组合条件</span>
<span class="co">*/</span>
<span class="cf">if</span>(CONST1 == value1 &amp;&amp; CONST2 == value2)
{
  <span class="co">// 某些动作1</span>
}
<span class="cf">else</span> <span class="cf">if</span>(CONST1 == value1 &amp;&amp; CONST3 == value2)
{
  <span class="co">// 某些动作2</span>
}
<span class="cf">else</span>
{
  <span class="co">// 默认动作</span>
}</code></pre></div>
</div>
<div id="fb.5-c" class="section level3">
<h3><span class="header-section-number">3.9.6</span> FB.5 C++异常风格的异常处理</h3>
<p>要善用异常，不要如<a href="http://google.github.io/styleguide/cppguide.html#Exceptions">Google C++ Style Guide： Exceptions</a>那般恐惧异常。</p>
<p>在有限的集中的位置捕获所有异常：</p>
<ul>
<li><code>try...catch</code>块在一个函数体内的范围应尽可能大，将整个主逻辑全部包含，在末端对所有异常统一处理，不要一步一异常。</li>
<li>上一条有个例外：<code>for/while</code>循环体，宜在每一次循环内捕获并处理异常，从而尽可能不让循环中止，除非本来就希望异常能中断循环。</li>
<li>不要每层函数都处理异常。最里层的函数，一般都可以直接抛异常。中间层次的函数，一般不处理所调用函数的异常，统一交给外层的函数来处理。</li>
<li>最外层一定要有兜底的异常捕获，避免不必要的程序终止。</li>
<li>如果是写公共库，那么公共库要定义自己的异常类型（更基础宽泛的语义），不要直接使用调用方侧的异常类型（更具体的语义）。调用方在异常穿越库与应用的边界时，要做异常类型的转换，并为其提供更多的语境信息。</li>
</ul>
<p>写异常安全的代码：</p>
<ul>
<li>捕获异常时应写至少3个<code>catch</code>块：业务自定义异常、<code>std::exception</code>、<code>...</code>。</li>
<li>捕获异常时应用const引用。</li>
<li>不要将整数、字符串等基础类型作为异常抛出，如：<code>throw (errno)</code>。</li>
<li>任何时候都要假设代码可能异常被中断，包括被异常、<code>break</code>、<code>return</code>等，熟练使用RAII技术做好资源管理，防止资源泄漏，见B.3 。</li>
<li>严禁使用带throw (XXXException)的异常声明，见FB.1 。</li>
</ul>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  良好的风格：</span>
<span class="co">*/</span>
<span class="dt">void</span> inner()
{
  <span class="cf">if</span>(conditionXXX)
  {
    <span class="cf">throw</span> XYZException(<span class="co">/* 错误码 */</span><span class="dv">123456</span>, <span class="co">/* 错误信息 */</span><span class="st">&quot;某某条件不满足&quot;</span>);
  }
}

<span class="dt">void</span> middle()
{
  inner();
}

<span class="dt">void</span> outter()
{
  <span class="cf">try</span>
  {
    middle();
  }
  <span class="cf">catch</span>(<span class="at">const</span> XYZException &amp; e)
  {
    <span class="co">// e.getErrorCode()</span>
    <span class="co">// e.getErrorInfo()</span>
  }
  <span class="cf">catch</span>(<span class="at">const</span> <span class="bu">std::</span>exception &amp; e)
  {
    <span class="co">// e.what();</span>
  }
  <span class="cf">catch</span>(...)
  {
    <span class="co">// 打印日志、统计或告警</span>
  }
}

var cycle()
{
  <span class="cf">while</span>(condition)
  {
    <span class="cf">try</span>
    {
      middle();
    }
    <span class="cf">catch</span>(<span class="at">const</span> XYZException &amp; e)
    {
      <span class="co">// e.getErrorCode()</span>
      <span class="co">// e.getErrorInfo()</span>
    }
    <span class="cf">catch</span>(<span class="at">const</span> <span class="bu">std::</span>exception &amp; e)
    {
      <span class="co">// e.what();</span>
    }
    <span class="cf">catch</span>(...)
    {
      <span class="co">// 打印日志、统计或告警</span>
    }
  }
}

<span class="co">/*</span>
<span class="co">  不良的风格：</span>
<span class="co">*/</span>
<span class="dt">void</span> fun()
{
  <span class="cf">try</span>
  {
    step1()
  }
  <span class="cf">catch</span>(<span class="at">const</span> XXXException&amp; e)
  {
    <span class="co">// ...</span>
  }

  <span class="cf">try</span>
  {
    step2()
  }
  <span class="cf">catch</span>(<span class="at">const</span> YYYException&amp; e)
  {
    <span class="co">// ...</span>
  }
}</code></pre></div>
</div>
<div id="fb.6-" class="section level3">
<h3><span class="header-section-number">3.9.7</span> FB.6 返回值风格的异常处理</h3>
<p>任何时候都要检查函数的返回值。如果因为一些原因，要对返回值进行忽略，应在代码上显式体现这个意图。</p>
<p>对返回值的检查如果不通过，应妥善处置，推荐将其转换成异常，见样例。</p>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> ret = doSth();

<span class="co">/*</span>
<span class="co">  不良的风格：</span>

<span class="co">  * 遇到问题只打印日志，却继续运行，可能带来不可预料的问题</span>
<span class="co">  * 日志是固定信息，没有具体的上下文，给问题定位带来不便</span>
<span class="co">*/</span>
<span class="cf">if</span>(ret != <span class="dv">0</span>)
{
  log(<span class="st">&quot;Something is wrong&quot;</span>);
}

<span class="co">/*</span>
<span class="co">  不良的风格：</span>

<span class="co">  * 遇到问题就返回了一个随手写的返回值幻数，调用者可能没有校验，就算校验也无法知道具体原因</span>
<span class="co">  * 没有留下带有上下文的日志信息，给问题定位带来不便</span>
<span class="co">*/</span>
<span class="cf">if</span>(ret != <span class="dv">0</span>)
{
  <span class="cf">return</span> <span class="dv">-6</span>;
}

<span class="co">/*</span>
<span class="co">  不良的风格：采用`do-while-false`惯用法和`break`关键字来实现错误集中处理</span>

<span class="co">  * 并不符合关键字本来的语义，别扭</span>
<span class="co">  * `break`可能在循环等情况下，出现非预期的行为</span>
<span class="co">  * 除了`break`之外，还有别的出错可能（如抛出异常），导致未能集中处理异常</span>

<span class="co">*/</span>
<span class="dt">int</span> errorNo = <span class="dv">0</span>;

<span class="cf">do</span>
{
  <span class="dt">int</span> ret = doSth();

  <span class="cf">if</span>(ret != <span class="dv">0</span>)
  {
    errorNo = <span class="dv">-6</span>;
    <span class="cf">break</span>;
  }
}
<span class="cf">while</span>(<span class="kw">false</span>);

handleErrorNo(errorNo);

<span class="co">/*</span>
<span class="co">  不良的风格：采用`goto`关键字来实现错误集中处理</span>

<span class="co">  * 违反C++语言设计理念</span>
<span class="co">  * 违反L.1</span>
<span class="co">  * 突破操守下限，带来破窗效应</span>

<span class="co">*/</span>
<span class="dt">int</span> errorNo = <span class="dv">0</span>;

<span class="dt">int</span> ret = doSth();

<span class="cf">if</span>(ret != <span class="dv">0</span>)
{
  errorNo = <span class="dv">-6</span>;
  <span class="cf">goto</span> Error;
}

Error:
  handleErrorNo(errorNo);

<span class="co">/*</span>
<span class="co">  良好的风格：将返回值转换为异常</span>
<span class="co">*/</span>
<span class="dt">void</span> assertTrue(<span class="dt">bool</span> condition, <span class="at">const</span> XXXException&amp; ex)
{
  <span class="cf">if</span>(!condition)
  {
    <span class="cf">throw</span> ex;
  }
}

<span class="dt">void</span> inner()
{
  <span class="dt">int</span> ret = doSth();
  assertTrue(<span class="dv">0</span> == ret, XYZException(<span class="co">/* 错误码 */</span><span class="dv">123456</span>, <span class="co">/* 错误信息 */</span><span class="st">&quot;某某条件不满足&quot;</span>));
}
<span class="co">// 此处略去一系列外层捕获与处理，详见FB.5</span></code></pre></div>
</div>
<div id="fb.7-" class="section level3">
<h3><span class="header-section-number">3.9.8</span> FB.7 日志打印</h3>
<p>日志打印应采用适当的技术手段：</p>
<ul>
<li>严禁使用printf、<code>std::cout</code>、<code>std::cerr</code>等方式打印，即使需要打印到标准输出/标准错误端，也应通过日志库来配置。程序运行起始应先初始化日志，初始化日子库失败可以回退到上述方式打印到标准输出/标准错误端。</li>
<li>本地日志应使用高性能（如异步写文件、高并发下线程安全）、稳定（代码质量过硬、经过实战考验趋于成熟、活跃维护中）、易定制（如每行开头的时间等信息、日志按天或按大小滚动）、轻量（代码量少可以通读代码对其充分掌握；依赖库少更独立）的日志库打印。</li>
<li>远程日志应使用带有本地缓冲且异步化的方式发送到远程日志服务器。</li>
</ul>
<p>日志打印的内容、数量应合理化：</p>
<ul>
<li>以下信息应体现为可被在代码运行时的黑盒外感知的可观测项，如果没有间接通过响应报文、持久化存储的数据、监控告警、抛异常等方式体现出来，就应通过日志体现出来：</li>
<li>调用底层库API的返回值、报错信息</li>
<li>所进入的关键的特殊分支和异常分支</li>
<li>程序的关键参数和进入的关键状态</li>
<li>其他如果日志中没有，定位问题的时候会非常抓瞎以至于需要单独上打印日志的版本的信息</li>
<li>日志打印应进行合理分级，并控制量级，至少使用如下几个级别：</li>
<li><code>ERROR</code>：程序出现严重问题 —— 这是追求性能情况下，生产系统设置的日志级别，数量要少之又少</li>
<li><code>INFO</code>：程序正常运行的关键参数、状态等 —— 这是一般情况下生产系统设置的日志级别，要控制数量不能泛滥</li>
<li><code>DEBUG</code>：程序在开发阶段或者问题定位阶段打印的日志 —— 这些并不是开发临时打印，而要为日后定位问题服务，内容上也不能随意，比如打印“test1”、“test2”等来找程序跑到哪悲剧的</li>
<li>日志应在一定程度上结构化：</li>
<li>每行开头应有固定的时间、文件、行号等内容，由日志库提供</li>
<li>随后应有结构化信息，如调用类型、时耗、错误码等，由应用框架提供</li>
<li>最后才是仅供人类阅读的文本内容</li>
<li>每行日志应提供独有的关键字，方便搜索过滤</li>
<li>仅供人类阅读的文本内容允许换行，但如果有日志结构化解析的程序，应考虑该情况</li>
<li>允许一个文件中有多于一种结构化方式，但要能让日志结构化解析的程序识别的标志</li>
<li>不应打印如下内容的日志：</li>
<li>日志内容固定而没有变化的上下文信息，如“进入XXX函数/XXX步骤”、“出错了！”</li>
<li>日志描述与实际运行状态不一样，或不易看懂（如语法错乱、用词不当的英文），从而形成误导</li>
<li>和即将抛出的异常信息相近的冗余日志（应交给异常捕捉者统一打印）</li>
<li>抖机灵、调侃、发泄等无意义内容</li>
</ul>
</div>
</div>
<div id="class-body" class="section level2">
<h2><span class="header-section-number">3.10</span> 类体代码组织（Class Body）</h2>
<div id="c.1-" class="section level3">
<h3><span class="header-section-number">3.10.1</span> C.1 构造函数应合理初始化</h3>
<p>构造函数应对所有成员变量进行初始化，并优先使用初始化列表（Initialization Lists）进行初始化，初始化顺序和成员变量声明顺序应一致，并且相关的成员变量应相邻。</p>
<p>构造函数中应该尽可能进行不易失败的轻操作，如果有特别重的初始化操作，可以考虑使用<a href="http://lux.dmcs.pl/symos/wyklady/04-TwoPhase.pdf">两阶段初始化（Two-Phase Construction）</a> 或<a href="https://en.wikipedia.org/wiki/Lazy_initialization">惰性初始化（Lazy initialization）</a>。</p>
<p>如果初始化失败或者使用上述两种延迟初始化的惯用法，则应通过异常、设置未初始化标志等可以被后继发现的方式体现其未完成初始化。后继操作时，应首先检查对象是否完成初始化。</p>
<p><strong>样例</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">  良好的风格</span>
<span class="co">*/</span>
<span class="kw">class</span> A
{
  <span class="kw">public</span>:
    A(<span class="dt">int</span> a, <span class="at">const</span> <span class="bu">std::</span>string &amp; b) : <span class="va">m_a</span>(a), <span class="va">m_b</span>(b)
    {

    }

    <span class="co">/* ...... */</span>

  <span class="kw">private</span>:
    <span class="dt">int</span> <span class="va">m_a</span>;
    <span class="bu">std::</span>string <span class="va">m_b</span>;
};</code></pre></div>
</div>
<div id="c.1-" class="section level3">
<h3><span class="header-section-number">3.10.2</span> C.1 类的成员（草稿中）</h3>
<ul>
<li>成员函数/变量，应按<code>public</code>、<code>protected</code>、<code>private</code>的顺序声明。</li>
<li>成员变量的命名规范见 N.5 。</li>
<li>成员函数的命名规范见 N.6 ，参数规范见 FB.1 ，尤其注意不修改成员变量的函数，应标注为<code>const</code>。</li>
<li>对于逻辑上不能在初始化后更改的成员变量，不应提供可修改它的成员函数（即“Setter函数”）。如果对一个成员变量提供了Setter函数，Setter函数应确保更新该成员变量变化之后，关联的其他成员变量得到更新，关联的动作得到执行，且对象的行为不会出现前后不一致等偏差。</li>
<li>对于非<code>public</code>的成员函数，可以考虑一律放在<code>protected</code>区，以供子类调用。</li>
<li>对于非<code>public</code>的成员变量，可以考虑一律放在<code>private</code>区，以防子类误修改或者过度依赖，如果希望为子类提供访问/修改的便利，可以考虑提供访问/修改的成员函数（<code>public</code>或<code>protected</code>）。</li>
</ul>
</div>
<div id="todo" class="section level3">
<h3><span class="header-section-number">3.10.3</span> TODO</h3>
<ul>
<li>拷贝构造函数等全或无</li>
<li>虚析构函数</li>
</ul>
</div>
</div>
<div id="section-3.11" class="section level2">
<h2><span class="header-section-number">3.11</span> 类组织</h2>
<ul>
<li>轻类</li>
<li>尽一切可能避免继承，优先使用组合</li>
</ul>
</div>
<div id="language-feature" class="section level2">
<h2><span class="header-section-number">3.12</span> 语言特性使用（Language Feature）</h2>
<div id="l.1-c" class="section level3">
<h3><span class="header-section-number">3.12.1</span> L.1 C语言特性使用</h3>
<ul>
<li>克制对宏的使用：</li>
<li>CCG ES.30: Don’t use macros for program text manipulation</li>
<li>CCG ES.31: Don’t use macros for constants or “functions”</li>
<li>CCG ES.33: If you must use macros, give them unique names</li>
<li>严禁使用如下特性：</li>
<li><code>goto</code></li>
</ul>
</div>
<div id="l.2-c9803" class="section level3">
<h3><span class="header-section-number">3.12.2</span> L.2 C++98/03语言特性使用</h3>
<ul>
<li>善用模版基础特性辅助类型推导和函数式泛型编程</li>
</ul>
<p><strong>参考</strong></p>
<p>《Extended STL》</p>
</div>
<div id="l.3-c1114" class="section level3">
<h3><span class="header-section-number">3.12.3</span> L.3 C++11/14语言特性使用</h3>
<ul>
<li><a href="http://herbsutter.com/elements-of-modern-c-style/">Elements of Modern C++ Style</a></li>
<li><a href="http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/">GotW #91 Solution: Smart Pointer Parameters</a></li>
<li><a href="http://herbsutter.com/gotw/">Guru of the Week(Revised for C++14)</a></li>
<li><a href="https://github.com/numenta/nupic/wiki/C--11-14-References">C++11/14 References</a></li>
</ul>
</div>
</div>
<div id="section-3.13" class="section level2">
<h2><span class="header-section-number">3.13</span> 标准库与第三方库使用</h2>
<p>第三方库可以从这里寻找备选者：<a href="https://github.com/fffaraz/awesome-cpp">Awesome C/C++</a></p>
</div>
<div id="section-3.14" class="section level2">
<h2><span class="header-section-number">3.14</span> 团队定制规则</h2>
<blockquote>
<p>注：团队可在此添加自己定制的规则，这里给出两个团队的定制规则作为样例：</p>
</blockquote>
<p>团队A:</p>
<ul>
<li>F.4 一致地使用4个空格</li>
<li>F.5 一致地使用“break”风格进行花括号换行</li>
<li>N.6 函数命名应采用<code>CamelCase</code>的格式，即每个单词的首字母都__大写__，其他字母小写，单词间直接相连</li>
<li>B.4 待定</li>
</ul>
<p>团队B:</p>
<ul>
<li>F.4 一致地使用4个空格</li>
<li>F.5 一致地使用“break”风格进行花括号换行</li>
<li>N.6 函数命名应采用<code>camelCase</code>的格式，即第一个单词首字母__小写__，其余单词首字母大写，其他字母小写，单词间直接相连</li>
<li>B.4 待定</li>
</ul>
<p><strong>因由</strong></p>
<ul>
<li>团队必然有自己的规则偏好，如果和上面的规则（称之为“通用规则”）冲突或有补充，可以在此：</li>
<li>废弃相应通用规则</li>
<li>指定通用规则中给出的几个备选规范中的某个</li>
<li>新写自己的定制规则</li>
<li>不建议直接修改/删除通用规则部分，因为将来通用规则部分如果更新增补，则不易整合进来。</li>
</ul>
<p><strong>参考</strong></p>
<blockquote>
<p>注：这里可以给出团队所在组织的内部参考文献。</p>
</blockquote>
</div>
<div id="section-3.15" class="section level2">
<h2><span class="header-section-number">3.15</span> 参考文献</h2>
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li>
<li><a href="http://llvm.org/docs/CodingStandards.html">LLVM Coding Standards</a></li>
<li><a href="http://www.gotw.ca/publications/c++cs.htm">C++ Coding Standards</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ Core Guidelines</a></li>
<li><a href="http://www.chromium.org/developers/coding-style">Chromium’s style guide</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style">Mozilla’s style guide</a></li>
<li><a href="http://www.webkit.org/coding/coding-style.html">WebKit’s style guide</a></li>
<li><a href="http://www.stroustrup.com/JSF-AV-rules.pdf">Joint Strike Fighter Air Vehicle C++ Coding Standards</a></li>
<li><a href="http://www.appinf.com/download/CppCodingStyleGuide.pdf">POCO C++ Libraries Coding Style Guide</a></li>
<li><a href="http://www.chromium.org/blink/coding-style">Blink Code Style</a></li>
<li><a href="https://github.com/numenta/nupic/wiki/C-Coding-Guide">NuPIC C++ Coding Guide</a></li>
<li><a href="http://www.chinastor.org/upload/2014-04/14040815326461.pdf">林锐的《高质量C++/C 编程指南》</a></li>
<li>TODO: 华为C++编码规范</li>
<li><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637">SEI CERT C++ Coding Standard</a>，也参见<a href="https://github.com/scriptum/cppcheck-rules">scriptum/cppcheck-rules</a></li>
<li><a href="http://principles-wiki.net/principles:start">Principles Wiki</a></li>
<li><a href="https://cwe.mitre.org/index.html">Common Weakness Enumeration</a></li>
</ul>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="summary.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="section-4.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/utensil/behind-programming/edit/master/cpp_coding_standards.md",
"text": "编辑"
},
"history": {
"link": null,
"text": null
},
"download": ["behind-programming.pdf", "behind-programming.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
